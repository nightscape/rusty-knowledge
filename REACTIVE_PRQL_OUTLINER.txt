COMPLETE OUTLINER-FLUTTER REACTIVE PRQL RENDERING REDESIGN

1. FEATURE CATALOG: Current outliner-flutter

Core Block Operations (BlockOps Interface)

BlockAccessOps (Synchronous read operations):
- getId() - Block unique identifier
- getContent() - Text content
- getChildren() - Child block list
- getIsCollapsed() - Collapse state
- getCreatedAt() - Creation timestamp
- getUpdatedAt() - Last modification timestamp

BlockTreeOps (Tree traversal & queries):
- getTopLevelBlocks() - Root-level blocks
- isDescendantOf() - Circular reference prevention
- findNextVisibleBlock() - Forward navigation respecting collapse
- findPreviousVisibleBlock() - Backward navigation respecting collapse
- findParent() - Parent lookup
- findBlockById() - ID-based search
- getRootBlock() - Root container access

BlockMutationOps (Async state changes):
- updateBlock() - Content modification
- deleteBlock() - Block removal
- moveBlock() - Drag-drop repositioning
- toggleCollapse() - Expand/collapse
- addChildBlock() - Append child
- addTopLevelBlock() - Add root-level block
- splitBlock() - Split at cursor position
- indentBlock() - Increase nesting
- outdentBlock() - Decrease nesting

BlockCreationOps (Factory methods):
- copyWith() - Immutable updates
- create() - New block creation
- createTopLevelBlockAsync() - Async root creation
- createChildBlockAsync() - Async child creation with index

State Management (OutlinerNotifier)

Focus Management:
- focusedBlockId - Currently focused block
- cursorPosition - Cursor state (start/end)
- setFocusedBlock() - Set focus with cursor position
- focusNextBlock() - Navigate forward
- focusPreviousBlock() - Navigate backward

View Management:
- viewRootId - Current view root (for zooming)
- setViewRoot() - Zoom to block
- resetViewRoot() - Return to full tree

Operation Proxies (Notifier convenience methods):
- indentFocusedBlock() - Tab operation
- outdentFocusedBlock() - Shift+Tab operation
- splitFocusedBlock() - Enter operation
- removeFocusedBlock() - Delete operation
- addChildToFocusedBlock() - Create child

UI Features (OutlinerListView + Widgets)

Rendering Components:
- Hierarchical list with variable depth
- Collapsible sections with expand/collapse icons
- Bullet points (simple dots for leaf nodes)
- Collapse indicators (arrows for parent nodes)
- Depth-based indentation
- Empty state handling

Editing Features:
- Inline text editing with TextField
- Focus management across blocks
- Cursor position preservation
- Placeholder text for empty blocks
- Edit/display mode switching

Drag-Drop System:
- LongPressDraggable for blocks
- Draggable for bullet points
- Three drop zones per block:
  - Before - Insert as previous sibling
  - After - Insert as next sibling
  - AsChild - Append as child
- Drop zone highlighting (animated)
- Drag feedback with subtree preview
- Constraint validation:
  - Prevent self-drop
  - Prevent drop on descendants (circular reference check)

Keyboard Shortcuts:
- Enter - Split block at cursor
- Tab - Indent block
- Shift+Tab - Outdent block
- ArrowUp - Navigate to previous block (at first line)
- ArrowDown - Navigate to next block (at last line)
- Backspace at start - Merge with previous (via delete)

Customization Points (Builder callbacks):
- blockBuilder - Custom block content rendering
- editingBlockBuilder - Custom editor widget
- bulletBuilder - Custom bullet/collapse indicator
- textFieldDecorationBuilder - TextField styling
- dragFeedbackBuilder - Custom drag preview
- dropZoneBuilder - Custom drop zone indicators
- emptyBuilder - Custom empty state

Styling Configuration (BlockStyle):
- Text styles (normal, empty, editing)
- Indent width per level
- Bullet size and color
- Bullet spacing
- Collapse icon size
- Content padding
- Empty block placeholder text

Architecture Characteristics

Lines of Code: ~3,243 total (lib + test)
- Core: ~800 lines (block_ops.dart, outliner_provider.dart, repositories)
- Widgets: ~1,200 lines (block_widget.dart, draggable_block_widget.dart,
outliner_list_view.dart)
- Models/Config: ~200 lines
- Tests: ~1,000 lines

Flexibility:
- Generic type parameter <T> - works with any block type
- Builder pattern for customization
- Separation of concerns (ops/state/UI)
- Repository abstraction (in-memory, could be DB-backed)

State Flow:
User Input ‚Üí BlockWidget ‚Üí OutlinerNotifier ‚Üí BlockOps ‚Üí Repository
                                                    ‚Üì
                                            changeStream emits
                                                    ‚Üì
                                          OutlinerNotifier updates
                                                    ‚Üì
                                          Riverpod notifies consumers
                                                    ‚Üì
                                            Widgets rebuild

---
2. LOWER-LEVEL BUILDING BLOCKS DESIGN

Primitive Component Catalog

Layout Primitives:
list(
  item_template: RenderNode,  // Template for each row
  indent_field: String,       // Column for indent level
  virtual_scroll: bool,       // Auto in Flutter
)

block(
  indent: Expr,              // Computed indent level
  bullet: RenderNode,        // Bullet/collapse widget
  content: RenderNode,       // Main content area
  behaviors: BehaviorRef,    // Attached operations
)

row(
  children: Vec<RenderNode>, // Horizontal layout
  spacing: f64,
  align: Alignment,
)

column(
  children: Vec<RenderNode>, // Vertical layout
  spacing: f64,
)

container(
  header: RenderNode,        // Fixed header
  body: RenderNode,          // Scrollable body (with each)
  footer: RenderNode,        // Fixed footer
)

Interactive Primitives:
editable_text(
  content: Expr,             // Text to display/edit
  on_edit: ActionRef,        // Update handler
  on_key: ActionRef,         // Keyboard handler
  cursors: Vec<Cursor>,      // Multi-user cursors (Loro)
  style: TextStyle,
)

button(
  text: String,
  icon: String,
  on_click: ActionRef,
)

checkbox(
  checked: Expr,             // Boolean expression
  on_toggle: ActionRef,
)

collapse_button(
  collapsed: Expr,           // Boolean state
  on_toggle: ActionRef,
  visible: Expr,             // Show only if has children
)

icon(
  source: String,            // Icon name or emoji
  color: String,
)

badge(
  text: Expr,
  color: String,
)

Drag-Drop Primitives:
draggable(
  child: RenderNode,
  drag_data: HashMap<String, Value>,  // Block ID, etc.
  feedback: RenderNode,               // Drag preview
)

drop_zone(
  child: RenderNode,
  position: DropPosition,     // Before/After/AsChild
  on_drop: ActionRef,
  constraints: Vec<Constraint>, // Validation rules
)

constrained_drag(
  invalid_targets: Vec<String>,  // From ancestor_path
  on_drop: ActionRef,
)
<!--
I would be interested in how drop_zone constraints and constrained_drag invalid_targets relate.
They seem to serve the same purpose
-->

Conditional Primitives:
visible(
  condition: Expr,           // Boolean expression
  child: RenderNode,
)

conditional(
  condition: Expr,
  if_true: RenderNode,
  if_false: RenderNode,
)

each(
  template: RenderNode,      // Applied to each row
  // Has access to both row fields AND aggregates
)

Extension Primitives (NEW):
extension_area(
  area_name: String,         // "metadata", "actions", etc.
  item_type: Expr,           // "task", "jira", "event"
  // Extensions register to inject components here
)

type_switch(
  type_expr: Expr,           // "task" | "jira" | "event"
  cases: HashMap<String, RenderNode>,
)

State Management Primitives:
ephemeral_state(
  doc_id: String,            // Loro ephemeral document
  path: String,              // "cursors", "selections"
  // Syncs in real-time, not persisted
)

persistent_state(
  table: String,             // Database table
  id_field: Expr,
  // Persisted across sessions
)

Missing Abstractions Identified

Needs from outliner-flutter NOT in basic primitives:

1. Focus/Cursor Context - Operations need explicit parameters:
on_key: block_keys(
  block_id: id,
  parent_id: parent_id,
  cursor_pos: @cursor,  // Implicit context
  focused_id: @focused  // Implicit context
)
2. Subtree Rendering - Recursive tree structure:
// Option A: Recursive query (nested SELECTs)
from blocks
derive children = (from blocks filter parent_id == blocks.id)

// Option B: Flatten with depth, filter client-side
from blocks_flattened  // Pre-computed with ancestor_path
filter not_ancestor_of_collapsed(ancestor_path, collapsed_blocks)
3. Context Propagation - Operations need block context:
behaviors: block_operations(
  id: id,
  parent_id: parent_id,
  has_children: exists(from blocks filter parent_id == blocks.id),
  operations: standard_block_ops
)
4. Multi-Cursor Management - Real-time cursor sync:
editable_text(
  content,
  cursors: ephemeral_state("cursors", "user_{id}"),
  show_labels: true
)
5. Variable-Height Virtualization - Flutter ListView.builder handles this:
// No explicit primitive needed - framework-level
list(...) // Implicitly virtualized in Flutter

---
3. COMPLETE PRQL + render() SPECIFICATION

Full Outliner Implementation

# ============================================================================
# OUTLINER: Complete LogSeq-style hierarchical block editor
# ============================================================================

# Shared operation definitions
let standard_block_ops = [
  {name: "indent", default_key: "Tab", icon: "‚Üí", description: "Indent block"},
  {name: "outdent", default_key: "Shift+Tab", icon: "‚Üê", description: "Outdent block"},
  {name: "split", default_key: "Enter", icon: "‚úÇ", description: "Split at cursor"},
  {name: "delete", default_key: "Ctrl+Shift+K", icon: "üóë", description: "Delete block"},
  {name: "add_child", default_key: "Ctrl+Shift+Down", icon: "‚Üì", description: "Add child"},
  {name: "merge_up", default_key: "Backspace@start", icon: "‚¨Ü", description: "Merge with
previous"},
  {name: "toggle_collapse", default_key: "Ctrl+Space", icon: "‚ñ∂", description:
"Collapse/expand"},
]

# Main query with hierarchical data
from blocks
filter workspace_id == @current_workspace
<!--
Instead of workspace_id we would rather filter by root_block_id
This would be the root block of the outline.
@current_workspace would be replaced by current_root_block_id which would actually be stored in Turso as well.
This way we get navigation and zooming into subtrees for free.
-->

# Compute tree structure fields
derive [
  # Precomputed for constraint checking (prevents circular refs)
  ancestor_path = recursive_ancestors(id, parent_id),

  # Tree metadata
  depth = count_ancestors(parent_id),
  has_children = exists(from blocks filter parent_id == blocks.id),
  is_visible = !any_ancestor_collapsed(id, collapsed_blocks),

  # Sort order (pre-order traversal)
  tree_order = compute_tree_order(parent_id, sort_order),
]

# Filter out collapsed subtrees
filter is_visible || depth == 0

# Sort by tree order (depth-first)
sort tree_order

# Join cursor state from ephemeral Loro doc
join cursor_state (==block_id)

# Join collapsed state from persistent DB
join collapsed_blocks (==block_id)

# ============================================================================
# RENDER SPECIFICATION
# ============================================================================

render(outliner(
  # List container with virtualization (implicit in Flutter)
  list_template: block(
    # Dynamic indentation based on depth
    indent: depth * 24,

    # Bullet point or collapse indicator
    bullet: collapse_button(
      visible: has_children,
      collapsed: collapsed_blocks.is_collapsed,
      on_toggle: toggle_collapse(id)
    ),

    # Main content area
    content: row(
      # Checkbox for task completion
      checkbox(
        checked: completed,
        on_toggle: update(id, {completed: !completed})
      ),

      # Editable text with multi-cursor support
      editable_text(
        content: content,
        on_edit: update(id, {content: $new_value}),
        on_key: block_keys(id, parent_id, depth),
        cursors: cursor_state.where(user_id != @current_user),
        show_cursor_labels: true,
        placeholder: "Empty block"
      ),

      # Extension area for system-specific metadata
      extension_area("metadata", item_type: item_type),
    ),

    # Drag-drop configuration
    drop_zones: [
      drop_zone(
        position: "before",
        on_drop: move_block($source_id, parent_id, sort_order - 1),
        invalid_targets: ancestor_path,  # Prevent circular refs
      ),
      drop_zone(
        position: "after",
        on_drop: move_block($source_id, parent_id, sort_order + 1),
        invalid_targets: ancestor_path,
      ),
      drop_zone(
        position: "as_child",
        on_drop: move_block($source_id, id, 0),
        invalid_targets: ancestor_path,
        visible: !collapsed_blocks.is_collapsed  # Only show if expanded
      ),
    ],

    # Attach standard block operations
    behaviors: block_operations(
      operations: standard_block_ops,
      id: id,
      parent_id: parent_id,
      depth: depth
    )
  )
))

<!--
The syntax for function calls in PRQL is `(func_name arg1: value1, arg2: value2)`
instead of `func_name(arg1: value1, arg2: value2)`.
-->

Multi-Type Outliner with Extensions

# ============================================================================
# MULTI-TYPE OUTLINER: Tasks + JIRA + Calendar + Email
# ============================================================================

from items  # Unified view across systems
filter workspace_id == @current_workspace

# Determine item type
derive [
  item_type = case [
    source == "todoist" => "task",
    source == "jira" => "issue",
    source == "calendar" => "event",
    source == "gmail" => "email",
    true => "unknown"
  ],

  # Tree structure (same as above)
  ancestor_path = recursive_ancestors(id, parent_id),
  depth = count_ancestors(parent_id),
  has_children = exists(from items filter parent_id == items.id),
]

# Join sync state
join sync_status (==item_id)

# Join cursor state (ephemeral)
join cursor_state (==item_id)

render(outliner(
  list_template: block(
    indent: depth * 24,

    bullet: collapse_button(
      visible: has_children,
      collapsed: collapsed_items.is_collapsed,
      on_toggle: toggle_collapse(id)
    ),

    content: row(
      # Core components (same for all types)
      icon(source: item_type_icon[item_type]),
      editable_text(
        content: title,
        on_edit: update(id, {title: $new_value}),
        on_key: block_keys(id, parent_id, depth),
        cursors: cursor_state.where(user_id != @current_user)
      ),

      # Sync state indicator
      badge(
        text: case [
          sync_status.state == "synced" => "‚úì",
          sync_status.state == "pending" => "‚è≥",
          sync_status.state == "conflict" => "‚ö†Ô∏è",
          true => ""
        ],
        color: sync_status_color[sync_status.state]
      ),

      # Extension area: System-specific metadata
      # - Todoist: project name, section, priority
      # - JIRA: story points, sprint, status badge
      # - Calendar: date, time, location
      # - Gmail: sender, subject, unread status
      extension_area("metadata", item_type: item_type),

      # Extension area: System-specific actions
      # - Todoist: "View in Todoist" button
      # - JIRA: "View in JIRA" button, "Log time"
      # - Calendar: "Join meeting" button
      # - Gmail: "Reply", "Archive"
      extension_area("actions", item_type: item_type),
    ),

    # Drag-drop with constraints
    drop_zones: [
      drop_zone(
        position: "before",
        on_drop: move_item($source_id, parent_id, sort_order - 1),
        invalid_targets: ancestor_path
      ),
      drop_zone(
        position: "after",
        on_drop: move_item($source_id, parent_id, sort_order + 1),
        invalid_targets: ancestor_path
      ),
      drop_zone(
        position: "as_child",
        on_drop: move_item($source_id, id, 0),
        invalid_targets: ancestor_path,
        visible: !collapsed_items.is_collapsed
      ),
    ],

    # Behaviors attached by name (registered in app code)
    behaviors: block_operations(
      operations: standard_block_ops,
      id: id,
      parent_id: parent_id,
      depth: depth
    )
  )
))

Outliner with Header/Footer Pattern

# ============================================================================
# OUTLINER WITH AGGREGATES: Header + Body + Footer
# ============================================================================

from blocks
filter workspace_id == @current_workspace

# Tree structure
derive [
  ancestor_path = recursive_ancestors(id, parent_id),
  depth = count_ancestors(parent_id),
  has_children = exists(from blocks filter parent_id == blocks.id),
  is_visible = !any_ancestor_collapsed(id, collapsed_blocks),
]

filter is_visible || depth == 0

# Compute aggregates (available in header/footer/body)
group workspace_id (
  derive [
    total_blocks = count this,
    completed_blocks = count(completed),
    incomplete_blocks = count(!completed),
    total_words = sum(word_count(content)),
  ]
)

render(container(
  # Header: Access to aggregates only
  header: row(
    icon("üìù"),
    text(workspace_name, weight: "bold", size: 18),
    badge(f"{completed_blocks}/{total_blocks} completed", color: "green"),
    badge(f"{total_words} words", color: "gray"),
  ),

  # Body: Each row has access to both row fields AND aggregates
  body: each(
    block(
      indent: depth * 24,
      bullet: collapse_button(
        visible: has_children,
        collapsed: collapsed_blocks.is_collapsed,
        on_toggle: toggle_collapse(id)
      ),
      content: row(
        checkbox(
          checked: completed,
          on_toggle: update(id, {completed: !completed})
        ),
        editable_text(
          content: content,
          on_edit: update(id, {content: $new_value}),
          on_key: block_keys(id, parent_id, depth),
        ),
        # Row can reference aggregates!
        badge(f"Block {row_index + 1}/{total_blocks}", color: "blue"),
      ),
      drop_zones: [
        drop_zone(position: "before", on_drop: move_block($source_id, parent_id, sort_order -
1)),
        drop_zone(position: "after", on_drop: move_block($source_id, parent_id, sort_order +
1)),
        drop_zone(position: "as_child", on_drop: move_block($source_id, id, 0)),
      ],
      behaviors: block_operations(operations: standard_block_ops, id: id, parent_id: parent_id)
    )
  ),

  # Footer: Access to aggregates only
  footer: row(
    button(
      text: "+ Add Block",
      icon: "‚ûï",
      on_click: create_block(workspace_id: @current_workspace, parent_id: null)
    ),
    button(
      text: "Export",
      icon: "üì§",
      on_click: export_workspace(@current_workspace)
    ),
  )
))

---
4. OPERATION REGISTRY MAPPING

Operation Signatures

Each operation receives explicit context - NO implicit state:

// ============================================================================
// OPERATION TRAIT
// ============================================================================

pub trait BlockOperation {
    fn name(&self) -> &str;
    fn execute(&self, ctx: &OperationContext, params: &OperationParams) -> Result<Action>;
}

// ============================================================================
// CONTEXT STRUCTURE
// ============================================================================

pub struct OperationContext {
    // Explicit parameters from render() call
    pub block_id: String,
    pub parent_id: Option<String>,
    pub depth: usize,

    // UI state (passed explicitly)
    pub cursor_pos: usize,
    pub focused_id: Option<String>,

    // Database access (for queries/validation)
    pub db: Arc<Database>,

    // Graph access (for constraint checking)
    pub ancestor_path: Vec<String>,  // From PRQL query
}

pub struct OperationParams {
    pub new_value: Option<Value>,  // For updates
    pub target_id: Option<String>, // For drag-drop
    pub key_event: Option<KeyEvent>, // For keyboard ops
}

// ============================================================================
// ACTION TYPES
// ============================================================================

pub enum Action {
    UpdateBlock {
        id: String,
        fields: HashMap<String, Value>,
    },
    CreateBlock {
        parent_id: Option<String>,
        index: usize,
        content: String,
    },
    DeleteBlock {
        id: String,
    },
    MoveBlock {
        id: String,
        new_parent_id: Option<String>,
        new_index: usize,
    },
    SetFocus {
        id: String,
        cursor_pos: CursorPosition,
    },
    Multiple(Vec<Action>),
    Reject {
        reason: String,
    },
}

// ============================================================================
// MAPPING TO BlockOps METHODS
// ============================================================================

impl BlockOperation for IndentOperation {
    fn name(&self) -> &str { "indent" }

    fn execute(&self, ctx: &OperationContext, _params: &OperationParams) -> Result<Action> {
        // Get previous sibling
        let siblings = ctx.db.query_siblings(ctx.parent_id)?;
        let current_index = siblings.iter().position(|b| b.id == ctx.block_id)?;

        if current_index == 0 {
            return Ok(Action::Reject {
                reason: "Cannot indent first block".to_string()
            });
        }

        let new_parent_id = siblings[current_index - 1].id.clone();
        let new_index = ctx.db.query_children(&new_parent_id)?.len();

        Ok(Action::MoveBlock {
            id: ctx.block_id.clone(),
            new_parent_id: Some(new_parent_id),
            new_index,
        })
    }
}

impl BlockOperation for OutdentOperation {
    fn name(&self) -> &str { "outdent" }

    fn execute(&self, ctx: &OperationContext, _params: &OperationParams) -> Result<Action> {
        if ctx.depth == 0 {
            return Ok(Action::Reject {
                reason: "Cannot outdent root block".to_string()
            });
        }

        let parent = ctx.db.query_block(ctx.parent_id.as_ref()?)?;
        let grandparent_id = parent.parent_id.clone();

        // Find parent's index in grandparent's children
        let siblings = ctx.db.query_children(&grandparent_id)?;
        let parent_index = siblings.iter().position(|b| b.id == parent.id)?;

        Ok(Action::MoveBlock {
            id: ctx.block_id.clone(),
            new_parent_id: grandparent_id,
            new_index: parent_index + 1,
        })
    }
}

impl BlockOperation for SplitOperation {
    fn name(&self) -> &str { "split" }

    fn execute(&self, ctx: &OperationContext, _params: &OperationParams) -> Result<Action> {
        let block = ctx.db.query_block(&ctx.block_id)?;
        let content = block.content;
        let cursor_pos = ctx.cursor_pos;

        let before = content[..cursor_pos].to_string();
        let after = content[cursor_pos..].to_string();

        // Find current index
        let siblings = ctx.db.query_children(&ctx.parent_id)?;
        let current_index = siblings.iter().position(|b| b.id == ctx.block_id)?;

        Ok(Action::Multiple(vec![
            Action::UpdateBlock {
                id: ctx.block_id.clone(),
                fields: hashmap!{
                    "content".to_string() => Value::String(before)
                },
            },
            Action::CreateBlock {
                parent_id: ctx.parent_id.clone(),
                index: current_index + 1,
                content: after,
            },
        ]))
    }
}

impl BlockOperation for DeleteOperation {
    fn name(&self) -> &str { "delete" }

    fn execute(&self, ctx: &OperationContext, _params: &OperationParams) -> Result<Action> {
        Ok(Action::DeleteBlock {
            id: ctx.block_id.clone(),
        })
    }
}

impl BlockOperation for MoveOperation {
    fn name(&self) -> &str { "move" }

    fn execute(&self, ctx: &OperationContext, params: &OperationParams) -> Result<Action> {
        let target_id = params.target_id.as_ref()?;

        // Constraint validation using precomputed ancestor_path
        if ctx.ancestor_path.contains(target_id) {
            return Ok(Action::Reject {
                reason: "Cannot move block to its own descendant".to_string()
            });
        }

        // Compute new index
        let new_children = ctx.db.query_children(target_id)?;
        let new_index = new_children.len();

        Ok(Action::MoveBlock {
            id: ctx.block_id.clone(),
            new_parent_id: Some(target_id.clone()),
            new_index,
        })
    }
}

impl BlockOperation for ToggleCollapseOperation {
    fn name(&self) -> &str { "toggle_collapse" }

    fn execute(&self, ctx: &OperationContext, _params: &OperationParams) -> Result<Action> {
        let current_state = ctx.db.query_collapsed_state(&ctx.block_id)?;

        Ok(Action::UpdateBlock {
            id: ctx.block_id.clone(),
            fields: hashmap!{
                "is_collapsed".to_string() => Value::Boolean(!current_state)
            },
        })
    }
}

// ============================================================================
// KEYBOARD HANDLER
// ============================================================================

pub struct BlockKeysHandler;

impl BlockKeysHandler {
    pub fn handle(&self, ctx: &OperationContext, key: &KeyEvent) -> Result<Action> {
        match (key.code, key.modifiers) {
            (KeyCode::Tab, KeyModifiers::NONE) => {
                IndentOperation.execute(ctx, &OperationParams::default())
            }
            (KeyCode::Tab, KeyModifiers::SHIFT) => {
                OutdentOperation.execute(ctx, &OperationParams::default())
            }
            (KeyCode::Enter, KeyModifiers::NONE) => {
                SplitOperation.execute(ctx, &OperationParams::default())
            }
            (KeyCode::Char('k'), KeyModifiers::CONTROL | KeyModifiers::SHIFT) => {
                DeleteOperation.execute(ctx, &OperationParams::default())
            }
            (KeyCode::ArrowUp, _) => {
                if ctx.cursor_pos == 0 {
                    let prev_block = ctx.db.query_previous_visible(&ctx.block_id)?;
                    Ok(Action::SetFocus {
                        id: prev_block.id,
                        cursor_pos: CursorPosition::End,
                    })
                } else {
                    Ok(Action::Reject { reason: "Not at start".to_string() })
                }
            }
            (KeyCode::ArrowDown, _) => {
                let content = ctx.db.query_block(&ctx.block_id)?.content;
                if ctx.cursor_pos == content.len() {
                    let next_block = ctx.db.query_next_visible(&ctx.block_id)?;
                    Ok(Action::SetFocus {
                        id: next_block.id,
                        cursor_pos: CursorPosition::Start,
                    })
                } else {
                    Ok(Action::Reject { reason: "Not at end".to_string() })
                }
            }
            _ => Ok(Action::Reject { reason: "Unhandled key".to_string() }),
        }
    }
}

<!--
The key handling would happen on the Flutter side.
Flutter would be responsible for
1. receiving a `Stream<List<Map<String, Value>>>` from the Rust backend via FRB,
2. displaying this and perform minimal updates for new Stream entries,
3. reacting to user interactions and sending operation requests back to Rust via FRB.
-->
// ============================================================================
// REGISTRATION SYSTEM
// ============================================================================

pub struct OperationRegistry {
    operations: HashMap<String, Box<dyn BlockOperation>>,
}

impl OperationRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            operations: HashMap::new(),
        };

        // Register standard operations
        registry.register(Box::new(IndentOperation));
        registry.register(Box::new(OutdentOperation));
        registry.register(Box::new(SplitOperation));
        registry.register(Box::new(DeleteOperation));
        registry.register(Box::new(MoveOperation));
        registry.register(Box::new(ToggleCollapseOperation));

        registry
    }

    pub fn register(&mut self, op: Box<dyn BlockOperation>) {
        self.operations.insert(op.name().to_string(), op);
    }

    pub fn execute(&self, op_name: &str, ctx: &OperationContext, params: &OperationParams) ->
Result<Action> {
        let op = self.operations.get(op_name)
            .ok_or_else(|| anyhow!("Unknown operation: {}", op_name))?;
        op.execute(ctx, params)
    }
}

Mapping to Current BlockOps Methods

| Operation       | Current Method                                | New Approach
                           |
|-----------------|-----------------------------------------------|--------------------------------------------------------|
| indent          | indentBlock(block)                            | execute(ctx, params) with explicit block_id, parent_id |
| outdent         | outdentBlock(block)                           | Same |
| split           | splitBlock(block, cursorPos)                  | cursor_pos in context, returns Action::Multiple        |
| delete          | deleteBlock(block)                            | Returns Action::DeleteBlock |
| move            | moveBlock(block, newParent, newIndex)         | Constraint check via ancestor_path in context          |
| toggle_collapse | toggleCollapse(block)                         | Returns Action::UpdateBlock |
| update_content  | updateBlock(block, content)                   | Returns Action::UpdateBlock |
| create_child    | createChildBlockAsync(parent, content, index) | Returns Action::CreateBlock |

Key Differences:
1. No block object passed - only IDs and explicit parameters
2. Context is explicit - cursor_pos, focused_id passed in
3. Actions returned - not directly mutating database
4. Constraint validation - uses precomputed ancestor_path from query
5. Composable - Multiple actions can be combined

---
5. MISSING ABSTRACTIONS ANALYSIS

What Can't Be Expressed with Basic Primitives?

1. Recursive Tree Rendering

Problem: PRQL is set-based (SQL), not recursive:

# ‚ùå DOESN'T WORK - No way to express nested structure in SQL result
from blocks
select [id, content, parent_id, children]  # children is NOT a column

Solutions:

Option A: Flatten Tree with Metadata (RECOMMENDED):
from blocks
derive [
  ancestor_path = recursive_ancestors(id, parent_id),
<!--
How would recursive_ancestors and friends be implemented without recursion?
What would the corresponding SQL look like?
-->
  depth = count_ancestors(parent_id),
  is_visible = !any_ancestor_collapsed(id, collapsed_blocks),
]
filter is_visible  # Client-side filtering via Flutter
sort tree_order    # Pre-order traversal
# Result: Flat list with depth, render as indented list
<!--
Would the children then still be enclosed in the parent widget?
This might make collapsing easier and also allow the visual effect of
dragging a subtree.
-->

Option B: Client-Side Tree Reconstruction:
// Query returns flat rows with parent_id
let rows: Vec<HashMap<String, Value>> = db.query(sql)?;

// Reconstruct tree client-side
let tree = build_tree(rows, "parent_id")?;

<!--
Would it be possible to make `build_tree` reactive
so that it only updates the part(s) of the tree where data changed?
Please research using Perplexity if there's Flutter/Dart libraries for reactive tree structures or collections.
If there isn't, please sketch how one might be implemented.
-->

// Render tree recursively
render_tree_recursive(tree, ui_spec)?;


Trade-off:
- Option A: More declarative, better for virtualization
- Option B: More flexible, worse for performance at scale

2. Cursor Position Context

Problem: Operations need to know cursor position, but PRQL doesn't have UI state:

# ‚ùå DOESN'T WORK - @cursor is not a database value
editable_text(
  content,
  on_key: split_block(id, @cursor)  # Where is cursor?
)

Solution: Pass cursor position from UI framework:

// Flutter TextField has TextEditingController
let cursor_pos = controller.selection.baseOffset;

// Pass to operation via context
let ctx = OperationContext {
    block_id: block.id,
    cursor_pos,  // From UI
    ..
};

operations.execute("split", &ctx, &OperationParams::default())?;

Abstraction Needed: @cursor syntax in PRQL ‚Üí resolved at runtime from UI state
<!--
I think we can and probably should store the cursor position in Turso.
In Loro it would be ephemeral state, but that doesn't preclude also caching it in Turso.
-->

3. Focus Management Across Blocks

Problem: Arrow key navigation needs to find previous/next visible block:

# ‚ùå DOESN'T WORK - Can't query "next visible block" reactively
on_key: if key == ArrowDown then focus_next_block(id)

Solution: findNextVisibleBlock() as database query:

// Generated SQL from PRQL helper
SELECT id FROM blocks
WHERE tree_order > (SELECT tree_order FROM blocks WHERE id = ?)
AND is_visible = 1
ORDER BY tree_order
LIMIT 1;

Abstraction Needed: find_next_visible(id) PRQL function ‚Üí compiled to SQL
<!--
I'm wondering if a linked list might make sense instead of the order field?
With a linked list, each block would have a next_id and previous_id field,
and moving a block would not require updating the order of all sibling blocks.
What I don't know is how exactly the UI would go about rendering the blocks in order then
without knowing deeply about the linked list structure.
Or maybe the PRQL somehow calculates both and in the `render` block we can use whichever makes more sense?
That would still leave open how the list is stored in the database.
Are there any best practices for implementing linked lists in SQL databases where moving item position is a standard operation?
-->

4. Multi-User Cursor Sync

Problem: Real-time cursor positions from other users (ephemeral state):

# ‚ùå DOESN'T WORK - Cursors are not in database
join cursor_state (==block_id)  # cursor_state is NOT a table
<!--
Cursor will probably be in the database.
-->

Solution: Hybrid approach - Loro ephemeral doc + database query:

// Query returns blocks
let blocks = db.query(sql)?;

// Get cursors from Loro (NOT database)
let cursors = loro_doc.get_cursors()?;

// Merge in render layer
for block in blocks {
    let block_cursors = cursors.iter()
        .filter(|c| c.block_id == block.id)
        .collect();
    render_block_with_cursors(block, block_cursors)?;
}

Abstraction Needed: ephemeral_state() primitive that renders know to fetch from Loro

5. Extension Registration System

Problem: How do extensions inject components?

# PRQL side - just declares extension area
extension_area("metadata", item_type: item_type)

// Rust side - extensions register
render_engine.register_extension("jira", |area, row_data| {
    match area {
        "metadata" => vec![
            RenderNode::Badge {
                text: row_data.get("story_points").map(|v| format!("{} pts", v)),
                color: "blue"
            },
        ],
        _ => vec![]
    }
});

Abstraction Needed: Extension registry + runtime component injection

Awkward or Verbose Patterns

1. Drop Zone Repetition

Current:
drop_zones: [
  drop_zone(position: "before", on_drop: move_block(...)),
  drop_zone(position: "after", on_drop: move_block(...)),
  drop_zone(position: "as_child", on_drop: move_block(...)),
]

Better:
drag_drop: constrained_drag(
  invalid_targets: ancestor_path,
  on_drop: move_block($source_id, $target_id, $position)
  # Drop zones auto-created with "before", "after", "as_child"
)

2. Conditional Visibility

Current:
visible(
  condition: has_children,
  child: collapse_button(...)
)

Better:
collapse_button(
  visible: has_children,  # Built-in conditional
  ...
)
<!--
Another option would be to use
```prql
case [
  has_children => collapse_button(...)
  true => empty()
]
```
This has slightly different sematics because the widget is not just invisible, but really not there.
I'm open to both.
-->

3. Behavior Registration Boilerplate

Current:
behaviors: block_operations(
  operations: standard_block_ops,
  id: id,
  parent_id: parent_id,
  depth: depth
)

Better:
# Implicit context - operations get id, parent_id, depth automatically
behaviors: standard_block_ops

New Building Blocks Needed

1. Recursive Query Functions:
let recursive_ancestors = func id, parent_id -> (
  # Compiled to SQL recursive CTE
  with recursive ancestors as (
    select id, parent_id, id as ancestor_id from blocks where id = $id
    union all
    select b.id, b.parent_id, a.ancestor_id
    from blocks b join ancestors a on b.parent_id = a.id
  )
  select group_concat(ancestor_id) from ancestors
)
<!--
Ah, ok. That answers my question about recursion above.
Is this a recursion with arbitrary depth?
-->

2. Ephemeral State Accessor:
let cursor_state = ephemeral("cursors")  # Loro doc, not DB table
<!-- Actually DB table -->

3. Implicit Context Variables:
@cursor          # Current cursor position (from UI)
@focused         # Currently focused block ID
@current_user    # Current user ID
@current_workspace  # Current workspace ID
<!--
Having current_workspace (I'm assuming this is the "page" of blocks that is currently displayed?) in a Turso table might actually be quite helpful:
When we change the current_workspace, the automatic view-updating mechanism would re-query the database and the UI would update accordingly.
So we basically get navigation for free.
-->

4. Extension Area Resolver:
// Framework-level, not in PRQL
extension_area("metadata", ...) ‚Üí calls registered extensions ‚Üí injects components

---
6. COMPLEXITY COMPARISON

Lines of Code Estimate

Current outliner-flutter:
- Core: ~800 lines (BlockOps, Notifier, Repository)
- Widgets: ~1,200 lines (BlockWidget, DraggableBlockWidget, OutlinerListView)
- Total implementation: ~2,000 lines

Reactive PRQL Rendering (estimated):

1. PRQL Query (~100-150 lines):
  - Hierarchical query with tree metadata
  - Cursor/collapsed state joins
  - Aggregates for header/footer
2. render() Specification (~200-300 lines):
  - Block template with all components
  - Drag-drop zones
  - Behavior attachments
  - Extension areas
3. Operation Registry (~400-500 lines):
  - 6-8 core operations (indent, outdent, split, delete, move, toggle, etc.)
  - Keyboard handler
  - Constraint validators
4. Extension Registry (~100-150 lines per system):
  - JIRA extension: story points, sprint badges
  - Todoist extension: project, section, priority
  - Calendar extension: date, time, location
  - Gmail extension: sender, subject, unread
5. UI Framework Bindings (~500-800 lines):
  - RenderNode ‚Üí Flutter widget mapping
  - Expression evaluator (ColumnRef, BinaryOp, etc.)
  - Action dispatcher (Action ‚Üí database mutation)
  - CDC polling loop

Total: ~1,800-2,500 lines

Winner: Reactive PRQL is similar in total LOC, BUT:
- ‚úÖ More declarative (PRQL + render spec vs. imperative Flutter)
- ‚úÖ Better separation (query/UI/behaviors vs. mixed concerns)
- ‚úÖ More extensible (extension areas vs. hardcoded)
- ‚ùå More complex architecture (more moving parts)

Flexibility Comparison

| Aspect               | outliner-flutter       | Reactive PRQL               | Winner |
|----------------------|------------------------|-----------------------------|--------------------------------|
| Custom rendering     | Builder callbacks      | Extension areas             | outliner-flutter (more direct) |
| Data access          | Direct block object    | Map<String, Value> from FFI | outliner-flutter (typed)       |
| State management     | Riverpod + Notifier    | CDC polling + Loro          | outliner-flutter (simpler)     |
| Extensibility        | Subclass or wrap       | Register extensions         | Reactive PRQL (plugin-like)    |
| Type safety          | Strong (Dart generics) | Weak (dynamic maps)         | outliner-flutter |
| Query flexibility    | Fixed (in-memory tree) | PRQL (any SQL query)        | Reactive PRQL |
| Multi-system support | Manual integration     | Extension areas             | Reactive PRQL |

Performance Comparison

| Aspect                | outliner-flutter     | Reactive PRQL             | Winner |
|-----------------------|----------------------|---------------------------|------------------------------------|
| FFI overhead          | None (pure Flutter)  | Per-block FFI call        | outliner-flutter |
| Re-render frequency   | Every change         | CDC polling (200ms)       | outliner-flutter (instant)         |
| Virtual scrolling     | ListView.builder     | Same (ListView.builder)   | Tie |
| Tree traversal        | In-memory (fast)     | SQL query (indexed)       | outliner-flutter (for small trees) |
| Large datasets        | O(N) in-memory       | O(log N) indexed queries  | Reactive PRQL (for 10k+ blocks)    |
| Partial updates       | Flutter diffing      | Same (Flutter diffing)    | Tie |
| Drag-drop constraints | O(N) recursive check | O(1) lookup (precomputed) | Reactive PRQL |

Testability Comparison

| Aspect            | outliner-flutter         | Reactive PRQL                             | Winner                     |
|-------------------|--------------------------|-------------------------------------------|----------------------------|
| Unit tests        | Test operations directly | Test PRQL ‚Üí SQL + UISpec                  | outliner-flutter (simpler) |
| Integration tests | Test widget tree         | Test end-to-end (query ‚Üí render ‚Üí action) | Tie |
| Property tests    | Difficult (stateful)     | Easier (query is pure function)           | Reactive PRQL              |
| Mocking           | Mock repository          | Mock database                             | Tie |

---
7. KEY QUESTIONS ANSWERED

Can ALL of outliner-flutter's functionality be expressed declaratively?

Answer: 95% YES, with hybrid approach for 5% imperative needs.

Declarative (via PRQL + render()):
- ‚úÖ Hierarchical tree structure
- ‚úÖ Collapsible sections
- ‚úÖ Indentation based on depth
- ‚úÖ Drag-drop with constraint validation (precomputed ancestor_path)
- ‚úÖ Checkbox toggling
- ‚úÖ Text editing
- ‚úÖ Focus management (via operations)
- ‚úÖ Cursor position preservation (via Loro)
- ‚úÖ Empty state handling
- ‚úÖ Custom block rendering (via extension areas)
- ‚úÖ Sync state indicators

Hybrid (PRQL declares, Rust implements):
- ‚ö†Ô∏è Keyboard shortcuts ‚Üí Operations (declared in PRQL, executed in Rust)
- ‚ö†Ô∏è Drag-drop validation ‚Üí Constraints (precomputed in PRQL, checked in Rust)
- ‚ö†Ô∏è Split at cursor ‚Üí Operation (cursor position from UI, split logic in Rust)

Escape Hatch (fully imperative):
- üîß Complex animations (not needed for outliner)
- üîß Custom gestures (could add gesture() primitive)
- üîß Advanced text editing (markdown preview, syntax highlighting)

Are the primitives sufficient or do we need higher-level components?

Answer: Primitives are sufficient with these additions:

Need to Add:
1. recursive_ancestors() - PRQL function for tree queries
2. ephemeral_state() - Access Loro docs from render spec
3. extension_area() - Plugin injection points
4. constrained_drag() - Drag-drop with validation
5. each() - Iterator for container body (with aggregate access)

Optional Higher-Level:
- outliner() - Convenience wrapper for common patterns
- task_block() - Pre-configured block with checkbox + text
- collapsible_section() - Block with collapse button

Trade-off: Higher-level components reduce boilerplate but decrease flexibility

How do custom block builders work in this paradigm?

Answer: Extension areas replace builder callbacks:

outliner-flutter approach:
OutlinerListView(
  blockBuilder: (context, block) {
    return CustomRichTextWidget(content: block.content);
  }
)

Reactive PRQL approach:
render(outliner(
  block_template: block(
    content: extension_area("content", item_type: item_type)
  )
))

// Register custom renderer
render_engine.register_extension("task", |area, row_data| {
    match area {
        "content" => vec![
            RenderNode::CustomComponent {
                name: "rich_text_editor",
                props: hashmap!{
                    "content" => row_data.get("content"),
                    "markdown" => row_data.get("markdown_enabled"),
                }
            }
        ],
        _ => vec![]
    }
});

Benefits:
- ‚úÖ Multiple extensions can contribute to same area
- ‚úÖ Extensions don't know about each other (loose coupling)
- ‚úÖ Core render spec stays clean

Limitations:
- ‚ùå Less type-safe than Dart generics
- ‚ùå Requires extension registration boilerplate

How does focus/cursor management work with operations?

Answer: Explicit context passing:

1. Focus state managed by UI framework (Flutter):
FocusNode focusNode = useFocusNode();
TextEditingController controller = useTextEditingController();

// On focus change
focusNode.addListener(() {
  if (focusNode.hasFocus) {
    // Notify operation registry
    ctx.focused_id = block.id;
    ctx.cursor_pos = controller.selection.baseOffset;
  }
});

2. Operations receive context:
pub struct OperationContext {
    pub focused_id: Option<String>,
    pub cursor_pos: usize,
    // ...
}

impl SplitOperation {
    fn execute(&self, ctx: &OperationContext, _params: &OperationParams) -> Result<Action> {
        let cursor_pos = ctx.cursor_pos;  // From UI
        // Split logic...
    }
}

3. Action dispatcher updates focus:
match action {
    Action::SetFocus { id, cursor_pos } => {
        // Flutter updates focus
        focus_controller.request_focus(id);
        text_controller.selection = TextSelection::collapsed(offset: cursor_pos);
    }
    // ...
}

Key Point: Focus is UI state, not database state ‚Üí passed explicitly to operations

Can drag-drop constraints be expressed cleanly?

Answer: YES, via precomputed ancestor_path:

PRQL query:
from blocks
derive [
  ancestor_path = recursive_ancestors(id, parent_id),
  # Returns: "root,parent1,parent2" for nested block
]

render(outliner(
  block_template: block(
    drop_zones: [
      drop_zone(
        position: "before",
        invalid_targets: ancestor_path,  # Pass ancestor list
        on_drop: move_block($source_id, parent_id, sort_order - 1)
      )
    ]
  )
))

Rust validation:
pub fn validate_drop(source_id: &str, target_id: &str, ancestor_path: &[String]) -> bool {
    // O(log N) binary search
    !ancestor_path.binary_search(&target_id.to_string()).is_ok()
}

Benefits:
- ‚úÖ O(log N) constraint checking (fast)
- ‚úÖ No round-trip to database for validation
- ‚úÖ Declaratively specified in PRQL
- ‚úÖ Constraint logic separate from UI

Comparison to outliner-flutter:
// outliner-flutter: O(N) recursive check every time
bool isDescendantOf(Block potentialAncestor, Block block) {
  if (getId(potentialAncestor) == getId(block)) return true;
  for (var child in getChildren(block)) {
    if (isDescendantOf(potentialAncestor, child)) return true;  // Recursive
  }
  return false;
}

Winner: Reactive PRQL (precomputed > recursive check)

---
8. FINAL VERDICT

Validation Result: ‚úÖ FEASIBLE with Hybrid Approach

The reactive PRQL rendering paradigm CAN handle a real, complex UI like outliner-flutter, but
requires:

1. Declarative Structure (PRQL + render):
  - Tree queries with metadata
  - Component composition
  - Extension areas for plugins
2. Imperative Behaviors (Rust operations):
  - Keyboard handlers
  - Drag-drop validation
  - Focus management
3. Hybrid State (Database + Loro):
  - Persistent: block content, collapsed state
  - Ephemeral: cursor positions, selections

Strengths

1. Extensibility: Extension areas enable unlimited system integrations
2. Performance: Precomputed constraints + indexed queries scale better
3. Separation: Query/UI/behaviors cleanly separated
4. Multi-system: Single paradigm works for tasks, JIRA, calendar, email

Weaknesses

1. Complexity: More moving parts than traditional approach
2. Type Safety: Dynamic maps vs. strongly-typed blocks
3. FFI Overhead: Per-row FFI call (vs. in-memory objects)
4. Learning Curve: Developers must understand PRQL + render spec + operations

Recommendation

Use reactive PRQL rendering for:
- ‚úÖ Multi-system integrations (tasks + JIRA + calendar)
- ‚úÖ Large datasets (10k+ blocks)
- ‚úÖ Plugin architectures
- ‚úÖ Cross-platform with shared backend

Use traditional approach for:
- ‚ùå Simple single-purpose UIs
- ‚ùå Mobile-first apps (FFI overhead)
- ‚ùå Real-time collaboration only (Loro + Flutter is simpler)

Next Steps to Validate

1. Implement split operation - Test cursor context passing
2. Test with 1000+ blocks - Validate virtual scrolling performance
3. Add JIRA extension - Validate extension area pattern
4. Measure FFI overhead - Profile Map<String, Value> per block
5. Compare to Flutter-only - Build same UI traditionally, measure LOC + time

---
APPENDIX: Component Implementations

editable_text() Primitive

PRQL Declaration:
editable_text(
  content: content,
  on_edit: update(id, {content: $new_value}),
  on_key: block_keys(id, parent_id, depth),
  cursors: cursor_state.where(user_id != @current_user),
  placeholder: "Empty block"
)

Flutter Implementation:
Widget buildEditableText(EditableTextNode node, Map<String, dynamic> row, OperationContext ctx)
{
  final controller = useTextEditingController(
    text: eval_expr(node.content, row)  // "content" ‚Üí row["content"]
  );
  final focusNode = useFocusNode();

  // Sync cursor state to Loro
  controller.addListener(() {
    if (focusNode.hasFocus) {
      loro_doc.set_cursor(row["id"], controller.selection.baseOffset);
    }
  });

  // Render remote cursors
  final cursors = eval_expr(node.cursors, row);  // Filter by user_id
  final cursorOverlays = cursors.map((c) =>
    CursorWidget(position: c.position, label: c.user_name)
  ).toList();

  return Stack(
    children: [
      TextField(
        controller: controller,
        focusNode: focusNode,
        decoration: InputDecoration(
          hintText: node.placeholder,
          border: InputBorder.none,
        ),
        onChanged: (newValue) {
          // Dispatch update action
          ctx.dispatch(Action::UpdateBlock {
            id: row["id"],
            fields: {"content": newValue},
          });
        },
        onKey: (event) {
          // Dispatch keyboard operation
          ctx.dispatch_key(node.on_key, event);
        },
      ),
      ...cursorOverlays,
    ],
  );
}

constrained_drag() Primitive

PRQL Declaration:
constrained_drag(
  invalid_targets: ancestor_path,  # ["root", "parent1", "parent2"]
  on_drop: move_block($source_id, $target_id, $position)
)

Flutter Implementation:
Widget buildConstrainedDrag(ConstrainedDragNode node, Map<String, dynamic> row, OperationContext
 ctx) {
  final invalidTargets = eval_expr(node.invalid_targets, row)
    .split(",")
    .toList();

  return DragTarget<DragData>(
    onWillAccept: (data) {
      // O(log N) validation
      return !invalidTargets.contains(data.blockId);
    },
    onAccept: (data) {
      // Dispatch move action
      ctx.dispatch(Action::MoveBlock {
        id: data.blockId,
        new_parent_id: row["id"],
        new_index: compute_index(data.position),
      });
    },
    builder: (context, candidateData, rejectedData) {
      return DropZoneIndicator(
        highlighted: candidateData.isNotEmpty,
      );
    },
  );
}

This completes the comprehensive analysis. The reactive PRQL rendering paradigm is viable for
complex UIs like outliner-flutter, with the caveat that it requires a hybrid approach
(declarative structure + imperative behaviors) and introduces architectural complexity in
exchange for extensibility and performance at scale.
