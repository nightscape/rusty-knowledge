-- ============================================================================
-- REACTIVE PRQL RENDERING: Turso/SQLite Schema
-- ============================================================================
-- Status: Design Specification
-- Date: 2025-01-03
-- Related: 0001-reactive-prql-rendering-primitives.md

-- ============================================================================
-- CORE BLOCKS TABLE
-- ============================================================================

CREATE TABLE blocks (
    -- Identity
    id TEXT PRIMARY KEY,
    parent_id TEXT,  -- NULL for root blocks

    -- Content
    content TEXT NOT NULL DEFAULT '',

    -- Ordering: Fractional indexing (lexicographic sort)
    -- Examples: "a0", "a1", "a1M" (midpoint between "a1" and "a2")
    -- Benefits: O(1) moves, simple queries (ORDER BY sort_key)
    sort_key TEXT NOT NULL,

    -- Metadata
    created_at INTEGER NOT NULL,  -- Unix timestamp (milliseconds)
    updated_at INTEGER NOT NULL,  -- Unix timestamp (milliseconds)

    -- CDC (Change Data Capture) columns
    _version INTEGER DEFAULT 0,   -- Incremented on each update
    _dirty INTEGER DEFAULT 0,     -- 1 = changed, 0 = synced

    -- Constraints
    FOREIGN KEY (parent_id) REFERENCES blocks(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_blocks_parent_id ON blocks(parent_id);
CREATE INDEX idx_blocks_sort_key ON blocks(sort_key);
CREATE INDEX idx_blocks_dirty ON blocks(_dirty);

-- ============================================================================
-- COLLAPSED STATE
-- ============================================================================
-- Tracks which blocks are collapsed (children hidden)
-- Persistent across sessions

CREATE TABLE collapsed_blocks (
    user_id TEXT NOT NULL,
    block_id TEXT NOT NULL,
    is_collapsed INTEGER NOT NULL DEFAULT 1,  -- 1 = collapsed, 0 = expanded
    updated_at INTEGER NOT NULL,

    PRIMARY KEY (user_id, block_id),
    FOREIGN KEY (block_id) REFERENCES blocks(id) ON DELETE CASCADE
);

CREATE INDEX idx_collapsed_blocks_user ON collapsed_blocks(user_id);

-- ============================================================================
-- CURSOR POSITIONS
-- ============================================================================
-- Hybrid storage: Persisted in Turso + Real-time in Loro
-- Turso: Periodic saves every 5 seconds + on blur
-- Loro: Sub-100ms real-time sync (ephemeral)

CREATE TABLE cursor_positions (
    user_id TEXT NOT NULL,
    block_id TEXT NOT NULL,
    cursor_pos INTEGER NOT NULL,  -- Character offset (0-based)
    updated_at INTEGER NOT NULL,

    PRIMARY KEY (user_id, block_id),
    FOREIGN KEY (block_id) REFERENCES blocks(id) ON DELETE CASCADE
);

CREATE INDEX idx_cursor_positions_user ON cursor_positions(user_id);
CREATE INDEX idx_cursor_positions_block ON cursor_positions(block_id);

-- ============================================================================
-- APP STATE
-- ============================================================================
-- Stores UI state for reactive navigation
-- When current_root_block_id changes → CDC triggers re-query → UI updates

CREATE TABLE app_state (
    user_id TEXT PRIMARY KEY,
    current_root_block_id TEXT,  -- Currently displayed root (NULL = show all)
    updated_at INTEGER NOT NULL,

    FOREIGN KEY (current_root_block_id) REFERENCES blocks(id) ON DELETE SET NULL
);

-- ============================================================================
-- RECURSIVE ANCESTORS (Virtual Column via PRQL)
-- ============================================================================
-- Not stored in table - computed in PRQL query using recursive CTE
-- Example output: "root,parent1,parent2,current"

-- SQL for recursive_ancestors function (generated by PRQL):
--
-- WITH RECURSIVE ancestors AS (
--   -- Base case: block itself
--   SELECT id, parent_id, id as ancestor_id, 0 as depth
--   FROM blocks
--   WHERE id = ?
--
--   UNION ALL
--
--   -- Recursive case: walk up parent chain
--   SELECT b.id, b.parent_id, a.parent_id as ancestor_id, a.depth + 1
--   FROM blocks b
--   JOIN ancestors a ON b.id = a.parent_id
--   WHERE a.parent_id IS NOT NULL
-- )
-- SELECT GROUP_CONCAT(ancestor_id, ',') as ancestor_path
-- FROM ancestors
-- ORDER BY depth DESC;

-- ============================================================================
-- TREE ORDER (Virtual Column via PRQL)
-- ============================================================================
-- For depth-first traversal, computed from sort_key
-- With fractional indexing, tree_order is simply a recursive concatenation:
-- tree_order = parent_sort_key + "." + sort_key

-- No separate column needed - ORDER BY sort_key within parent_id is sufficient

-- ============================================================================
-- EXAMPLE QUERIES
-- ============================================================================

-- Query 1: Get all visible blocks for current root (flat list)
--
-- WITH RECURSIVE tree AS (
--   -- Start from current root
--   SELECT *, 0 as depth
--   FROM blocks
--   WHERE id = @current_root_block_id
--
--   UNION ALL
--
--   -- Recursively get children
--   SELECT b.*, t.depth + 1
--   FROM blocks b
--   JOIN tree t ON b.parent_id = t.id
-- )
-- SELECT *
-- FROM tree
-- WHERE NOT EXISTS (
--   SELECT 1 FROM collapsed_blocks cb
--   WHERE cb.user_id = @current_user
--     AND cb.block_id = tree.parent_id
--     AND cb.is_collapsed = 1
-- )
-- ORDER BY sort_key;

-- Query 2: Move block between siblings (fractional indexing)
--
-- Example: Move block "B" between "A" (sort_key="a1") and "C" (sort_key="a2")
-- New sort_key for B: midpoint("a1", "a2") = "a1M"
--
-- UPDATE blocks
-- SET sort_key = fractional_midpoint(
--   (SELECT sort_key FROM blocks WHERE id = 'prev_sibling_id'),
--   (SELECT sort_key FROM blocks WHERE id = 'next_sibling_id')
-- ),
-- _dirty = 1,
-- _version = _version + 1
-- WHERE id = 'block_to_move_id';

-- Query 3: Get dirty blocks for CDC polling
--
-- SELECT id, content, sort_key, parent_id, _version
-- FROM blocks
-- WHERE _dirty = 1;

-- Query 4: Mark blocks as clean after sync
--
-- UPDATE blocks
-- SET _dirty = 0
-- WHERE id IN (?, ?, ?);

-- ============================================================================
-- CDC TRIGGERS (Optional - Auto-mark dirty on changes)
-- ============================================================================

CREATE TRIGGER blocks_update_dirty
AFTER UPDATE ON blocks
FOR EACH ROW
BEGIN
    UPDATE blocks
    SET _dirty = 1,
        _version = _version + 1,
        updated_at = unixepoch('now', 'subsec') * 1000
    WHERE id = NEW.id;
END;

CREATE TRIGGER blocks_insert_dirty
AFTER INSERT ON blocks
FOR EACH ROW
BEGIN
    UPDATE blocks
    SET _dirty = 1
    WHERE id = NEW.id;
END;

-- ============================================================================
-- FRACTIONAL INDEXING HELPER FUNCTIONS
-- ============================================================================
-- These would be implemented in Rust, not SQLite

-- Rust pseudo-code:
--
-- fn fractional_midpoint(key1: &str, key2: &str) -> String {
--     // Lexicographic midpoint algorithm
--     // Examples:
--     //   midpoint("a1", "a2") = "a1M"
--     //   midpoint("a1M", "a2") = "a1T"
--     //   midpoint("a", "b") = "a0"
--
--     // See: https://github.com/davidaurelio/fractional-index-rs
--     // Or: https://observablehq.com/@dgreensp/implementing-fractional-indexing
-- }

-- ============================================================================
-- SAMPLE DATA
-- ============================================================================

-- Root block
INSERT INTO blocks (id, parent_id, content, sort_key, created_at, updated_at, _dirty)
VALUES ('root', NULL, 'Root block', 'a0', 1704279600000, 1704279600000, 0);

-- Child blocks (sorted by sort_key)
INSERT INTO blocks (id, parent_id, content, sort_key, created_at, updated_at, _dirty)
VALUES
    ('block-1', 'root', 'First child', 'a0', 1704279600000, 1704279600000, 0),
    ('block-2', 'root', 'Second child', 'a1', 1704279600000, 1704279600000, 0),
    ('block-3', 'root', 'Third child', 'a2', 1704279600000, 1704279600000, 0);

-- Nested block
INSERT INTO blocks (id, parent_id, content, sort_key, created_at, updated_at, _dirty)
VALUES ('block-1-1', 'block-1', 'Nested block', 'a0', 1704279600000, 1704279600000, 0);

-- Collapsed state for user
INSERT INTO collapsed_blocks (user_id, block_id, is_collapsed, updated_at)
VALUES ('user-1', 'block-1', 1, 1704279600000);

-- App state for user (zoomed to root)
INSERT INTO app_state (user_id, current_root_block_id, updated_at)
VALUES ('user-1', 'root', 1704279600000);

-- Cursor positions
INSERT INTO cursor_positions (user_id, block_id, cursor_pos, updated_at)
VALUES ('user-1', 'block-2', 5, 1704279600000);

-- ============================================================================
-- PERFORMANCE NOTES
-- ============================================================================

-- 1. Fractional Indexing:
--    - O(1) moves (single UPDATE, no sibling reordering)
--    - Simple queries: ORDER BY sort_key
--    - Key length growth: ~1 char per 26 insertions in same interval
--    - Rebalancing needed after ~1000 insertions between same two blocks
--
-- 2. CDC Polling:
--    - Polling interval: 200ms (feels responsive)
--    - Query cost: SELECT WHERE _dirty = 1 (indexed)
--    - Typical: 0-10 dirty blocks per poll
--
-- 3. Recursive CTE (ancestor_path):
--    - Cost: O(depth) per block
--    - Typical depth: 5-10 levels
--    - Precomputed in query, cached in result
--
-- 4. Indexes:
--    - parent_id: For tree traversal
--    - sort_key: For ordering
--    - _dirty: For CDC polling
--    - User-specific indexes: For multi-tenant queries

-- ============================================================================
-- MIGRATION STRATEGY (From Integer Order to Fractional Indexing)
-- ============================================================================

-- Step 1: Add sort_key column
-- ALTER TABLE blocks ADD COLUMN sort_key TEXT;

-- Step 2: Populate sort_key from existing order field
-- UPDATE blocks
-- SET sort_key = generate_fractional_keys_from_order(order_index);

-- Step 3: Create index
-- CREATE INDEX idx_blocks_sort_key ON blocks(sort_key);

-- Step 4: Drop old order column
-- ALTER TABLE blocks DROP COLUMN order_index;

-- ============================================================================
-- FUTURE ENHANCEMENTS
-- ============================================================================

-- 1. Block Types (for multi-type rendering)
--
-- ALTER TABLE blocks ADD COLUMN item_type TEXT DEFAULT 'block';
-- CREATE INDEX idx_blocks_item_type ON blocks(item_type);

-- 2. Sync Status (for multi-device sync)
--
-- CREATE TABLE sync_status (
--     block_id TEXT PRIMARY KEY,
--     state TEXT NOT NULL,  -- 'synced', 'pending', 'conflict'
--     last_synced_at INTEGER,
--     FOREIGN KEY (block_id) REFERENCES blocks(id) ON DELETE CASCADE
-- );

-- 3. Block Properties (key-value metadata)
--
-- CREATE TABLE block_properties (
--     block_id TEXT NOT NULL,
--     key TEXT NOT NULL,
--     value TEXT,
--     PRIMARY KEY (block_id, key),
--     FOREIGN KEY (block_id) REFERENCES blocks(id) ON DELETE CASCADE
-- );

-- 4. Full-text search
--
-- CREATE VIRTUAL TABLE blocks_fts USING fts5(
--     content,
--     content=blocks,
--     content_rowid=rowid
-- );

-- ============================================================================
-- TESTING QUERIES
-- ============================================================================

-- Test 1: Get flat list ordered by sort_key
--
-- SELECT id, parent_id, content, sort_key
-- FROM blocks
-- WHERE parent_id = 'root'
-- ORDER BY sort_key;
--
-- Expected: block-1, block-2, block-3 (in fractional order)

-- Test 2: Move block between siblings
--
-- -- Move block-3 between block-1 and block-2
-- UPDATE blocks
-- SET sort_key = fractional_midpoint('a0', 'a1')  -- Returns 'a0M'
-- WHERE id = 'block-3';
--
-- Expected sort_key: 'a0M'

-- Test 3: CDC polling
--
-- -- Mark block as dirty
-- UPDATE blocks SET _dirty = 1 WHERE id = 'block-2';
--
-- -- Poll for dirty blocks
-- SELECT id FROM blocks WHERE _dirty = 1;
--
-- Expected: ['block-2']

-- Test 4: Recursive ancestor path
--
-- WITH RECURSIVE ancestors AS (
--   SELECT id, parent_id, id as ancestor_id, 0 as depth
--   FROM blocks
--   WHERE id = 'block-1-1'
--   UNION ALL
--   SELECT b.id, b.parent_id, a.parent_id as ancestor_id, a.depth + 1
--   FROM blocks b
--   JOIN ancestors a ON b.id = a.parent_id
--   WHERE a.parent_id IS NOT NULL
-- )
-- SELECT GROUP_CONCAT(ancestor_id, ',') as ancestor_path
-- FROM ancestors
-- ORDER BY depth DESC;
--
-- Expected: 'root,block-1,block-1-1'
