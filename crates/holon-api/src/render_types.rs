use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;

use crate::Value;

/// flutter_rust_bridge:ignore
pub type PreconditionChecker = dyn Fn(&HashMap<String, Box<dyn std::any::Any + Send + Sync>>) -> Result<bool, String>
    + Send
    + Sync;

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderSpec {
    pub root: RenderExpr,
    pub nested_queries: Vec<String>,
    /// Automatically inferred operation wirings from lineage analysis
    /// Probably obsolete here, as we have the operations directly in the FunctionCall nodes now
    pub operations: HashMap<String, OperationWiring>,
    /// Per-row templates for heterogeneous UNION queries.
    /// Each template has an index that corresponds to the `ui` column value in SQL results.
    /// Operations are wired based on each template's source entity.
    #[serde(default)]
    pub row_templates: Vec<RowTemplate>,
}

/// Per-row UI template for heterogeneous data rendering.
///
/// When a PRQL query uses `derive { ui = (render ...) }` after a `from <table>`,
/// the compiler extracts the render expression and assigns it an index.
/// The SQL output will have `<index> as ui` for that table's rows.
/// At render time, Flutter looks up `row['ui']` to find the right template.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RowTemplate {
    /// Index used in the `ui` column to identify this template
    pub index: usize,
    /// Source entity name (e.g., "todoist_tasks", "todoist_projects")
    /// Used for wiring operations to the correct entity
    pub entity_name: String,
    /// Short name for entity-typed params (e.g., "task", "project")
    /// Used for generating drop target params like "task_id", "project_id"
    pub entity_short_name: String,
    /// The render expression with operations pre-wired for this entity
    pub expr: RenderExpr,
}

/// Complete metadata for an operation
///
/// Generated by #[operations_trait] macro.
/// flutter_rust_bridge:non_opaque
#[derive(Clone, Serialize, Deserialize)]
pub struct OperationDescriptor {
    // Entity and table identification
    pub entity_name: String, // "todoist_tasks", "logseq_blocks"
    /// Short name for entity-typed params (e.g., "task" for task_id, "project" for project_id)
    pub entity_short_name: String,
    pub id_column: String, // "id"

    // Operation metadata
    pub name: String,         // "set_completion", "indent", "create"
    pub display_name: String, // "Mark as complete", "Indent"
    pub description: String,  // Human-readable description for UI
    pub required_params: Vec<OperationParam>,
    /// Fields that this operation affects (for pie menu auto-attachment)
    pub affected_fields: Vec<String>, // ["is_collapsed"], ["parent_id", "depth", "sort_key"], etc.
    /// How to derive required params from alternative sources (e.g., tree_position â†’ parent_id)
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub param_mappings: Vec<ParamMapping>,

    /// flutter_rust_bridge:opaque
    #[serde(skip_serializing, skip_deserializing)]
    pub precondition: Option<Arc<Box<PreconditionChecker>>>,
}

impl std::fmt::Debug for OperationDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("OperationDescriptor")
            .field("entity_name", &self.entity_name)
            .field("entity_short_name", &self.entity_short_name)
            .field("id_column", &self.id_column)
            .field("name", &self.name)
            .field("display_name", &self.display_name)
            .field("description", &self.description)
            .field("required_params", &self.required_params)
            .field("affected_fields", &self.affected_fields)
            .field("param_mappings", &self.param_mappings)
            .field(
                "precondition",
                &self.precondition.as_ref().map(|_| "<closure>"),
            )
            .finish()
    }
}

/// An executable operation with all parameters
///
/// Operations can be executed through the OperationProvider trait,
/// and each operation can return its inverse operation for undo support.
/// flutter_rust_bridge:non_opaque
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Operation {
    /// Entity name (e.g., "todoist-task", "logseq-block")
    pub entity_name: String,
    /// Operation name (e.g., "move_block", "set_completion")
    pub op_name: String,
    /// Human-readable display name for UI (e.g., "Move block", "Complete task")
    pub display_name: String,
    /// Operation parameters as key-value pairs
    pub params: HashMap<String, Value>,
}

impl Operation {
    /// Create a new operation
    pub fn new(
        entity_name: impl Into<String>,
        op_name: impl Into<String>,
        display_name: impl Into<String>,
        params: HashMap<String, Value>,
    ) -> Self {
        Self {
            entity_name: entity_name.into(),
            op_name: op_name.into(),
            display_name: display_name.into(),
            params,
        }
    }

    /// Create an operation from a hashmap (convenience method)
    pub fn from_params(
        entity_name: impl Into<String>,
        op_name: impl Into<String>,
        display_name: impl Into<String>,
        params: impl IntoIterator<Item = (String, Value)>,
    ) -> Self {
        Self {
            entity_name: entity_name.into(),
            op_name: op_name.into(),
            display_name: display_name.into(),
            params: params.into_iter().collect(),
        }
    }

    /// Set the entity name (useful when entity_name is not known at construction time)
    pub fn with_entity_name(mut self, entity_name: impl Into<String>) -> Self {
        self.entity_name = entity_name.into();
        self
    }
}

/// Type hints for operation parameters
///
/// Encodes whether a parameter is a primitive value or an entity reference.
/// Entity references enable the test infrastructure to track dependencies.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum TypeHint {
    /// Boolean value
    Bool,
    /// String value
    String,
    /// Numeric value (integer)
    Number,
    /// Reference to an entity ID
    ///
    /// Example: `EntityId { entity_name: "project" }` means this parameter
    /// must be the ID of a "project" entity.
    EntityId { entity_name: String },
}

impl TypeHint {
    /// Convert from legacy string format for backward compatibility
    pub fn from_string(s: &str) -> Self {
        match s {
            "bool" | "boolean" => TypeHint::Bool,
            "string" | "str" => TypeHint::String,
            "number" | "integer" | "int" | "i64" | "i32" => TypeHint::Number,
            s if s.starts_with("entity_id:") => {
                let entity_name = s.strip_prefix("entity_id:").unwrap().to_string();
                TypeHint::EntityId { entity_name }
            }
            _ => TypeHint::String, // Default fallback
        }
    }

    /// Convert to legacy string format for backward compatibility
    pub fn to_string_legacy(&self) -> String {
        match self {
            TypeHint::Bool => "bool".to_string(),
            TypeHint::String => "string".to_string(),
            TypeHint::Number => "number".to_string(),
            TypeHint::EntityId { entity_name } => format!("entity_id:{}", entity_name),
        }
    }
}

/// Parameter descriptor for operation metadata
///
/// Describes a required parameter for an operation.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationParam {
    pub name: String, // "completed", "new_parent_id"
    #[serde(deserialize_with = "deserialize_type_hint")]
    pub type_hint: TypeHint, // Now enum instead of String
    pub description: String, // "Whether task is completed"
}

/// Describes how to derive required parameters from alternative sources.
///
/// Enables auto-discovery: widgets provide generic params (like `tree_position` or `selected_id`),
/// and operations declare how to map those to their specific `required_params`.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ParamMapping {
    /// Source param name from widget (e.g., "tree_position", "selected_id")
    pub from: String,
    /// Which required params this source provides (e.g., ["parent_id", "predecessor"])
    pub provides: Vec<String>,
    /// Default values for params not extractable from source
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub defaults: HashMap<String, Value>,
}

/// Custom deserializer for TypeHint that supports both old string format and new enum format
fn deserialize_type_hint<'de, D>(deserializer: D) -> Result<TypeHint, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de::{self, Visitor};
    use std::fmt;

    struct TypeHintVisitor;

    impl<'de> Visitor<'de> for TypeHintVisitor {
        type Value = TypeHint;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("a string or TypeHint enum")
        }

        fn visit_str<E>(self, value: &str) -> Result<TypeHint, E>
        where
            E: de::Error,
        {
            Ok(TypeHint::from_string(value))
        }

        fn visit_map<M>(self, map: M) -> Result<TypeHint, M::Error>
        where
            M: de::MapAccess<'de>,
        {
            // Delegate to default deserialization for enum format
            let mut map = map;
            let mut type_field: Option<String> = None;
            let mut entity_name: Option<String> = None;

            while let Some(key) = map.next_key::<String>()? {
                match key.as_str() {
                    "type" => {
                        type_field = Some(map.next_value()?);
                    }
                    "entity_name" => {
                        entity_name = Some(map.next_value()?);
                    }
                    _ => {
                        let _ = map.next_value::<de::IgnoredAny>()?;
                    }
                }
            }

            match type_field.as_deref() {
                Some("entity_id") | Some("EntityId") => {
                    let entity_name =
                        entity_name.ok_or_else(|| de::Error::missing_field("entity_name"))?;
                    Ok(TypeHint::EntityId { entity_name })
                }
                Some("bool") | Some("Bool") => Ok(TypeHint::Bool),
                Some("string") | Some("String") => Ok(TypeHint::String),
                Some("number") | Some("Number") => Ok(TypeHint::Number),
                _ => Err(de::Error::custom("Unknown type hint variant")),
            }
        }
    }

    deserializer.deserialize_any(TypeHintVisitor)
}

/// Connects lineage analysis results to operation metadata
///
/// Embedded in FunctionCall nodes in RenderSpec and sent to Flutter frontend.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationWiring {
    // Lineage-derived UI binding info
    pub widget_type: String,    // "checkbox", "text", "button"
    pub modified_param: String, // "checked", "content", "onClick"

    // Complete operation metadata (no duplication!)
    pub descriptor: OperationDescriptor,
}

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
//#[serde(tag = "type", rename_all = "snake_case")]
pub enum RenderExpr {
    FunctionCall {
        name: String,
        args: Vec<Arg>,
        //#[serde(skip_serializing_if = "Vec::is_empty", default)]
        operations: Vec<OperationWiring>,
    },
    ColumnRef {
        name: String,
    },
    Literal {
        value: Value,
    },
    //Literal { value: String },
    BinaryOp {
        op: BinaryOperator,
        left: Box<RenderExpr>,
        right: Box<RenderExpr>,
    },
    Array {
        items: Vec<RenderExpr>,
    },
    Object {
        fields: HashMap<String, RenderExpr>,
    },
}

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Arg {
    pub name: Option<String>,
    pub value: RenderExpr,
}

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum BinaryOperator {
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    Add,
    Sub,
    Mul,
    Div,
    And,
    Or,
}

/// A unified object combining row data, template, and operations.
///
/// This enables uni-directional data flow where operations are always
/// available with the item, avoiding repeated lookups.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderableItem {
    pub row_data: HashMap<String, Value>,
    pub template: RowTemplate,
    pub operations: Vec<OperationDescriptor>,
}

impl RenderableItem {
    /// Create a new RenderableItem, extracting operations from the template if not provided
    ///
    /// flutter_rust_bridge:ignore
    pub fn new(
        row_data: HashMap<String, Value>,
        template: RowTemplate,
        operations: Option<Vec<OperationDescriptor>>,
    ) -> Self {
        let operations = operations.unwrap_or_else(|| Self::extract_operations(&template.expr));
        Self {
            row_data,
            template,
            operations,
        }
    }

    /// Extract operations from the root FunctionCall of a RenderExpr
    ///
    /// flutter_rust_bridge:ignore
    fn extract_operations(expr: &RenderExpr) -> Vec<OperationDescriptor> {
        if let RenderExpr::FunctionCall { operations, .. } = expr {
            operations.iter().map(|w| w.descriptor.clone()).collect()
        } else {
            Vec::new()
        }
    }
}
