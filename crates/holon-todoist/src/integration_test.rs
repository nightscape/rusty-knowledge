use crate::{TodoistTask, TodoistTaskDataSource};
use holon::core::datasource::{CrudOperations, DataSource};
use holon::core::predicate::Eq;
use holon::core::queryable_cache::QueryableCache;
use holon::core::traits::Queryable;
use holon_api::Value;
use std::collections::HashMap;

#[cfg(test)]
#[cfg(feature = "integration-tests")]
mod tests {
    use super::*;

    fn get_api_key() -> String {
        std::env::var("TODOIST_TEST_API_KEY")
            .expect("TODOIST_TEST_API_KEY environment variable must be set")
    }

    #[tokio::test]
    async fn test_todoist_datasource_with_cache() {
        let api_key = get_api_key();

        let datasource = TodoistTaskDataSource::from_api_key(&api_key);

        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        cache.sync().await.expect("Failed to sync cache");

        let all_tasks = cache.get_all().await.expect("Failed to get all tasks");
        println!("Fetched {} tasks from Todoist", all_tasks.len());

        for task in all_tasks.iter().take(5) {
            println!("  - {} ({})", task.content, task.id);
        }
    }

    #[tokio::test]
    async fn test_query_incomplete_todoist_tasks() {
        let api_key = get_api_key();

        let datasource = TodoistTaskDataSource::from_api_key(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        cache.sync().await.expect("Failed to sync cache");

        use crate::models::CompletedLens;

        let incomplete_predicate = Eq::new(CompletedLens, false);
        let incomplete_tasks = cache
            .query(incomplete_predicate)
            .await
            .expect("Failed to query incomplete tasks");

        println!("Found {} incomplete tasks", incomplete_tasks.len());
        for task in incomplete_tasks.iter().take(10) {
            println!("  - {} (priority: {})", task.content, task.priority);
        }
    }

    #[tokio::test]
    async fn test_query_high_priority_tasks() {
        let api_key = get_api_key();

        let datasource = TodoistTaskDataSource::from_api_key(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        cache.sync().await.expect("Failed to sync cache");

        use crate::models::PriorityLens;
        use holon::core::predicate::Gt;

        let high_priority_pred = Gt::new(PriorityLens, 2);
        let high_priority_tasks = cache
            .query(high_priority_pred)
            .await
            .expect("Failed to query high priority tasks");

        println!("Found {} high-priority tasks", high_priority_tasks.len());
        for task in high_priority_tasks.iter() {
            println!(
                "  - {} (priority: {}, completed: {})",
                task.content, task.priority, task.completed
            );
        }
    }

    #[tokio::test]
    async fn test_create_and_delete_task() {
        let api_key = get_api_key();

        let datasource = TodoistTaskDataSource::from_api_key(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        let test_project_id = std::env::var("TODOIST_TEST_PROJECT_ID")
            .expect("TODOIST_TEST_PROJECT_ID environment variable not set");

        let new_task = TodoistTask::new(
            String::new(), // ID will be generated by Todoist
            "Test task created by holon".to_string(),
            test_project_id,
        );

        // Create task using new API
        let mut fields = HashMap::new();
        fields.insert(
            "content".to_string(),
            Value::String(new_task.content.clone()),
        );
        fields.insert(
            "project_id".to_string(),
            Value::String(new_task.project_id.clone()),
        );
        let task_id =
            <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::create(&cache, fields)
                .await
                .expect("Failed to create task");
        println!("Created task with ID: {}", task_id);

        let created_task = <QueryableCache<_, TodoistTask> as DataSource<TodoistTask>>::get_by_id(
            &cache, &task_id,
        )
        .await
        .expect("Failed to fetch created task")
        .expect("Task not found");
        println!("Retrieved task: {}", created_task.content);

        <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::delete(&cache, &task_id)
            .await
            .expect("Failed to delete task");
        println!("Deleted task: {}", task_id);

        let deleted_task = cache
            .get_by_id(&task_id)
            .await
            .expect("Failed to fetch after delete");
        assert!(deleted_task.is_none(), "Task should be deleted");
    }

    #[tokio::test]
    async fn test_update_task() {
        let api_key = get_api_key();

        let datasource = TodoistTaskDataSource::from_api_key(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        let test_project_id = std::env::var("TODOIST_TEST_PROJECT_ID")
            .expect("TODOIST_TEST_PROJECT_ID environment variable not set");

        let new_task = TodoistTask::new(
            String::new(),
            "Task to be updated".to_string(),
            test_project_id,
        );

        // Create task using new API
        let mut fields = HashMap::new();
        fields.insert(
            "content".to_string(),
            Value::String(new_task.content.clone()),
        );
        fields.insert(
            "project_id".to_string(),
            Value::String(new_task.project_id.clone()),
        );
        let task_id =
            <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::create(&cache, fields)
                .await
                .expect("Failed to create task");

        let mut task_to_update =
            <QueryableCache<_, TodoistTask> as DataSource<TodoistTask>>::get_by_id(
                &cache, &task_id,
            )
            .await
            .expect("Failed to fetch task")
            .expect("Task not found");

        task_to_update.content = "Updated task content".to_string();
        task_to_update.priority = 3; // High priority
        task_to_update.description = Some("This task was updated by holon".to_string());

        // Update using set_field for each field
        <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::set_field(
            &cache,
            &task_id,
            "content",
            Value::String(task_to_update.content.clone()),
        )
        .await
        .expect("Failed to update content");
        <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::set_field(
            &cache,
            &task_id,
            "priority",
            Value::Integer(task_to_update.priority as i64),
        )
        .await
        .expect("Failed to update priority");
        <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::set_field(
            &cache,
            &task_id,
            "description",
            Value::String(task_to_update.description.clone().unwrap_or_default()),
        )
        .await
        .expect("Failed to update description");

        let updated_task = <QueryableCache<_, TodoistTask> as DataSource<TodoistTask>>::get_by_id(
            &cache, &task_id,
        )
        .await
        .expect("Failed to fetch updated task")
        .expect("Task not found");

        assert_eq!(updated_task.content, "Updated task content");
        assert_eq!(updated_task.priority, 3);
        assert_eq!(
            updated_task.description,
            Some("This task was updated by holon".to_string())
        );

        <QueryableCache<_, TodoistTask> as CrudOperations<TodoistTask>>::delete(&cache, &task_id)
            .await
            .expect("Failed to delete task");
    }
}
