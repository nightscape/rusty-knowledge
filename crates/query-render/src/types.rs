use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;

/// Type alias for precondition checker closure
///
/// This closure takes a HashMap of parameter names to values and returns
/// whether the precondition is satisfied. The actual Value type will be provided
/// when the closure is constructed in the macro (storage::types::Value).
///
/// Note: This uses a generic HashMap<String, Box<dyn Any>> to avoid requiring
/// query-render to depend on rusty-knowledge storage types. The macro will
/// generate code that downcasts the values appropriately.
///
/// Wrapped in Arc to allow cloning of OperationDescriptor.
pub type PreconditionChecker = dyn Fn(&HashMap<String, Box<dyn std::any::Any + Send + Sync>>) -> Result<bool, String> + Send + Sync;

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderSpec {
    pub root: RenderExpr,
    pub nested_queries: Vec<String>,
    /// Automatically inferred operation wirings from lineage analysis
    /// Probably obsolete here, as we have the operations directly in the FunctionCall nodes now
    pub operations: HashMap<String, OperationWiring>,
}

/// Complete metadata for an operation
///
/// Generated by #[operations_trait] macro.
/// flutter_rust_bridge:non_opaque
#[derive(Clone, Serialize, Deserialize)]
pub struct OperationDescriptor {
    // Entity and table identification
    pub entity_name: String,        // "todoist-task", "logseq-block"
    pub table: String,              // "todoist_tasks", "logseq_blocks"
    pub id_column: String,          // "id"

    // Operation metadata
    pub name: String,               // "set_completion", "indent_block", "create"
    pub display_name: String,        // "Mark as complete", "Indent"
    pub description: String,        // Human-readable description for UI
    pub required_params: Vec<OperationParam>,

    // Design-by-contract precondition
    /// Precondition closure that validates method arguments before execution
    /// None if no precondition is specified
    /// Wrapped in Arc to allow cloning of OperationDescriptor
    /// Skipped in serialization since closures cannot be serialized
    #[serde(skip)]
    pub precondition: Option<Arc<Box<PreconditionChecker>>>,
}

impl std::fmt::Debug for OperationDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("OperationDescriptor")
            .field("entity_name", &self.entity_name)
            .field("table", &self.table)
            .field("id_column", &self.id_column)
            .field("name", &self.name)
            .field("display_name", &self.display_name)
            .field("description", &self.description)
            .field("required_params", &self.required_params)
            .field("precondition", &self.precondition.as_ref().map(|_| "<closure>"))
            .finish()
    }
}

/// Type hints for operation parameters
///
/// Encodes whether a parameter is a primitive value or an entity reference.
/// Entity references enable the test infrastructure to track dependencies.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum TypeHint {
    /// Boolean value
    Bool,
    /// String value
    String,
    /// Numeric value (integer)
    Number,
    /// Reference to an entity ID
    ///
    /// Example: `EntityId { entity_name: "project" }` means this parameter
    /// must be the ID of a "project" entity.
    EntityId {
        entity_name: String,
    },
}

impl TypeHint {
    /// Convert from legacy string format for backward compatibility
    pub fn from_string(s: &str) -> Self {
        match s {
            "bool" | "boolean" => TypeHint::Bool,
            "string" | "str" => TypeHint::String,
            "number" | "integer" | "int" | "i64" | "i32" => TypeHint::Number,
            s if s.starts_with("entity_id:") => {
                let entity_name = s.strip_prefix("entity_id:").unwrap().to_string();
                TypeHint::EntityId { entity_name }
            }
            _ => TypeHint::String, // Default fallback
        }
    }

    /// Convert to legacy string format for backward compatibility
    pub fn to_string_legacy(&self) -> String {
        match self {
            TypeHint::Bool => "bool".to_string(),
            TypeHint::String => "string".to_string(),
            TypeHint::Number => "number".to_string(),
            TypeHint::EntityId { entity_name } => format!("entity_id:{}", entity_name),
        }
    }
}

/// Parameter descriptor for operation metadata
///
/// Describes a required parameter for an operation.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationParam {
    pub name: String,               // "completed", "new_parent_id"
    #[serde(deserialize_with = "deserialize_type_hint")]
    pub type_hint: TypeHint,         // Now enum instead of String
    pub description: String,        // "Whether task is completed"
}

/// Custom deserializer for TypeHint that supports both old string format and new enum format
fn deserialize_type_hint<'de, D>(deserializer: D) -> Result<TypeHint, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de::{self, Visitor};
    use std::fmt;

    struct TypeHintVisitor;

    impl<'de> Visitor<'de> for TypeHintVisitor {
        type Value = TypeHint;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("a string or TypeHint enum")
        }

        fn visit_str<E>(self, value: &str) -> Result<TypeHint, E>
        where
            E: de::Error,
        {
            Ok(TypeHint::from_string(value))
        }

        fn visit_map<M>(self, map: M) -> Result<TypeHint, M::Error>
        where
            M: de::MapAccess<'de>,
        {
            // Delegate to default deserialization for enum format
            let mut map = map;
            let mut type_field: Option<String> = None;
            let mut entity_name: Option<String> = None;

            while let Some(key) = map.next_key::<String>()? {
                match key.as_str() {
                    "type" => {
                        type_field = Some(map.next_value()?);
                    }
                    "entity_name" => {
                        entity_name = Some(map.next_value()?);
                    }
                    _ => {
                        let _ = map.next_value::<de::IgnoredAny>()?;
                    }
                }
            }

            match type_field.as_deref() {
                Some("entity_id") | Some("EntityId") => {
                    let entity_name = entity_name.ok_or_else(|| {
                        de::Error::missing_field("entity_name")
                    })?;
                    Ok(TypeHint::EntityId { entity_name })
                }
                Some("bool") | Some("Bool") => Ok(TypeHint::Bool),
                Some("string") | Some("String") => Ok(TypeHint::String),
                Some("number") | Some("Number") => Ok(TypeHint::Number),
                _ => Err(de::Error::custom("Unknown type hint variant")),
            }
        }
    }

    deserializer.deserialize_any(TypeHintVisitor)
}

/// Connects lineage analysis results to operation metadata
///
/// Embedded in FunctionCall nodes in RenderSpec and sent to Flutter frontend.
/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationWiring {
    // Lineage-derived UI binding info
    pub widget_type: String,        // "checkbox", "text", "button"
    pub modified_param: String,     // "checked", "content", "onClick"

    // Complete operation metadata (no duplication!)
    pub descriptor: OperationDescriptor,
}


/// flutter_rust_bridge:non_opaque
#[derive(Clone, Debug)]
pub enum Number {
    Int(i64),
    Float(f64),
}

/// flutter_rust_bridge:non_opaque
#[derive(Clone, Debug)]
pub enum Value {
    Null,
    Bool(bool),
    Number(Number),
    String(String),
    Array(Vec<Value>),
    Object(HashMap<String, Value>),
}

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum RenderExpr {
    FunctionCall {
        name: String,
        args: Vec<Arg>,
        #[serde(skip_serializing_if = "Vec::is_empty", default)]
        operations: Vec<OperationWiring>,
    },
    ColumnRef { name: String },
    Literal { value: serde_json::Value },
    //Literal { value: String },
    BinaryOp {
        op: BinaryOperator,
        left: Box<RenderExpr>,
        right: Box<RenderExpr>,
    },
    Array { items: Vec<RenderExpr> },
    Object { fields: HashMap<String, RenderExpr> },
}

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Arg {
    pub name: Option<String>,
    pub value: RenderExpr,
}

/// flutter_rust_bridge:non_opaque
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum BinaryOperator {
    Eq,
    Neq,
    Gt,
    Lt,
    Gte,
    Lte,
    Add,
    Sub,
    Mul,
    Div,
    And,
    Or,
}
