use crate::core::predicate::Eq;
use crate::core::queryable_cache::QueryableCache;
use crate::core::traits::{DataSource, Queryable};
use crate::integrations::todoist::{TodoistDataSource, TodoistTask};

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    #[ignore] // Requires valid API key
    async fn test_todoist_datasource_with_cache() {
        let api_key =
            std::env::var("TODOIST_API_KEY").expect("TODOIST_API_KEY environment variable not set");

        let datasource = TodoistDataSource::new(&api_key);

        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        cache.sync().await.expect("Failed to sync cache");

        let all_tasks = cache.get_all().await.expect("Failed to get all tasks");
        println!("Fetched {} tasks from Todoist", all_tasks.len());

        for task in all_tasks.iter().take(5) {
            println!("  - {} ({})", task.content, task.id);
        }
    }

    #[tokio::test]
    #[ignore] // Requires valid API key
    async fn test_query_incomplete_todoist_tasks() {
        let api_key =
            std::env::var("TODOIST_API_KEY").expect("TODOIST_API_KEY environment variable not set");

        let datasource = TodoistDataSource::new(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        cache.sync().await.expect("Failed to sync cache");

        use crate::integrations::todoist::models::CompletedLens;

        let incomplete_predicate = Eq::new(CompletedLens, false);
        let incomplete_tasks = cache
            .query(incomplete_predicate)
            .await
            .expect("Failed to query incomplete tasks");

        println!("Found {} incomplete tasks", incomplete_tasks.len());
        for task in incomplete_tasks.iter().take(10) {
            println!("  - {} (priority: {})", task.content, task.priority);
        }
    }

    #[tokio::test]
    #[ignore] // Requires valid API key
    async fn test_query_high_priority_tasks() {
        let api_key =
            std::env::var("TODOIST_API_KEY").expect("TODOIST_API_KEY environment variable not set");

        let datasource = TodoistDataSource::new(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        cache.sync().await.expect("Failed to sync cache");

        use crate::core::predicate::Gt;
        use crate::integrations::todoist::models::PriorityLens;

        let high_priority_pred = Gt::new(PriorityLens, 2);
        let high_priority_tasks = cache
            .query(high_priority_pred)
            .await
            .expect("Failed to query high priority tasks");

        println!("Found {} high-priority tasks", high_priority_tasks.len());
        for task in high_priority_tasks.iter() {
            println!(
                "  - {} (priority: {}, completed: {})",
                task.content, task.priority, task.completed
            );
        }
    }

    #[tokio::test]
    #[ignore] // Requires valid API key
    async fn test_create_and_delete_task() {
        let api_key =
            std::env::var("TODOIST_API_KEY").expect("TODOIST_API_KEY environment variable not set");

        let datasource = TodoistDataSource::new(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        let test_project_id = std::env::var("TODOIST_TEST_PROJECT_ID")
            .expect("TODOIST_TEST_PROJECT_ID environment variable not set");

        let new_task = TodoistTask::new(
            String::new(), // ID will be generated by Todoist
            "Test task created by rusty-knowledge".to_string(),
            test_project_id,
        );

        let task_id = cache.insert(new_task).await.expect("Failed to create task");
        println!("Created task with ID: {}", task_id);

        let created_task = cache
            .get_by_id(&task_id)
            .await
            .expect("Failed to fetch created task")
            .expect("Task not found");
        println!("Retrieved task: {}", created_task.content);

        cache.delete(&task_id).await.expect("Failed to delete task");
        println!("Deleted task: {}", task_id);

        let deleted_task = cache
            .get_by_id(&task_id)
            .await
            .expect("Failed to fetch after delete");
        assert!(deleted_task.is_none(), "Task should be deleted");
    }

    #[tokio::test]
    #[ignore] // Requires valid API key
    async fn test_update_task() {
        let api_key =
            std::env::var("TODOIST_API_KEY").expect("TODOIST_API_KEY environment variable not set");

        let datasource = TodoistDataSource::new(&api_key);
        let cache = QueryableCache::with_database(datasource, ":memory:")
            .await
            .expect("Failed to create cache");

        let test_project_id = std::env::var("TODOIST_TEST_PROJECT_ID")
            .expect("TODOIST_TEST_PROJECT_ID environment variable not set");

        let new_task = TodoistTask::new(
            String::new(),
            "Task to be updated".to_string(),
            test_project_id,
        );

        let task_id = cache.insert(new_task).await.expect("Failed to create task");

        let mut task_to_update = cache
            .get_by_id(&task_id)
            .await
            .expect("Failed to fetch task")
            .expect("Task not found");

        task_to_update.content = "Updated task content".to_string();
        task_to_update.priority = 3; // High priority
        task_to_update.description = Some("This task was updated by rusty-knowledge".to_string());

        cache
            .update(&task_id, task_to_update)
            .await
            .expect("Failed to update task");

        let updated_task = cache
            .get_by_id(&task_id)
            .await
            .expect("Failed to fetch updated task")
            .expect("Task not found");

        assert_eq!(updated_task.content, "Updated task content");
        assert_eq!(updated_task.priority, 3);
        assert_eq!(
            updated_task.description,
            Some("This task was updated by rusty-knowledge".to_string())
        );

        cache.delete(&task_id).await.expect("Failed to delete task");
    }
}
