// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../third_party/holon_api.dart';
import '../third_party/holon_api/render_types.dart';
import '../third_party/holon_api/streaming.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `create_span_from_context`, `init_opentelemetry`

/// Initialize a render engine with a database at the given path
///
/// Uses dependency injection to properly configure the engine with all registered providers.
/// The engine is stored in a global singleton to prevent premature disposal.
///
/// # Parameters
/// * `db_path` - Path to the database file
/// * `config` - Configuration map (e.g., API keys like "TODOIST_API_KEY", paths like "ORGMODE_ROOT_DIRECTORY")
Future<ArcBackendEngine> initRenderEngine({
  required String dbPath,
  required Map<String, String> config,
}) => RustLib.instance.api.crateApiFfiBridgeInitRenderEngine(
  dbPath: dbPath,
  config: config,
);

/// Compile a PRQL query, execute it, and set up CDC streaming
///
/// This combines query compilation, execution, and change watching into a single call.
/// Returns the render specification, current query results, and a stream of ongoing changes.
///
/// # Returns
/// A tuple containing:
/// - `RenderSpec`: UI rendering specification from the PRQL query
/// - `Vec<HashMap<String, Value>>`: Current query results
/// - `RowChangeStream`: Stream of ongoing changes to the query results
///
/// # UI Usage
/// The UI should:
/// 1. Subscribe to the RowChangeStream using StreamBuilder in Flutter
/// 2. Key widgets by entity ID from data.get("id"), NOT by rowid
/// 3. Handle Added/Updated/Removed events to update UI
///
Future<(RenderSpec, List<Map<String, Value>>)> queryAndWatch({
  required String prql,
  required Map<String, Value> params,
  required MapChangeSink sink,
  TraceContext? traceContext,
}) => RustLib.instance.api.crateApiFfiBridgeQueryAndWatch(
  prql: prql,
  params: params,
  sink: sink,
  traceContext: traceContext,
);

/// Get available operations for an entity
///
/// Returns a list of operation descriptors available for the given entity_name.
/// Use "*" as entity_name to get wildcard operations.
///
/// # FFI Function
/// This is exposed to Flutter via flutter_rust_bridge
Future<List<OperationDescriptor>> availableOperations({
  required String entityName,
}) => RustLib.instance.api.crateApiFfiBridgeAvailableOperations(
  entityName: entityName,
);

/// Execute an operation on the database
///
/// # FFI Function
/// This is exposed to Flutter via flutter_rust_bridge
///
/// Operations mutate the database directly. UI updates happen via CDC streams.
/// This follows the unidirectional data flow: Action → Model → View
///
/// # Note
/// This function does NOT return new data. Changes propagate through:
/// Operation → DB mutation → CDC event → watch_query stream → UI update
Future<void> executeOperation({
  required String entityName,
  required String opName,
  required Map<String, Value> params,
  TraceContext? traceContext,
}) => RustLib.instance.api.crateApiFfiBridgeExecuteOperation(
  entityName: entityName,
  opName: opName,
  params: params,
  traceContext: traceContext,
);

/// Check if an operation is available for an entity
///
/// # FFI Function
/// This is exposed to Flutter via flutter_rust_bridge
///
/// # Returns
/// `true` if the operation is available, `false` otherwise
Future<bool> hasOperation({
  required String entityName,
  required String opName,
}) => RustLib.instance.api.crateApiFfiBridgeHasOperation(
  entityName: entityName,
  opName: opName,
);

/// Undo the last operation
///
/// Executes the inverse operation from the undo stack and pushes it to the redo stack.
/// Returns true if an operation was undone, false if the undo stack is empty.
Future<bool> undo() => RustLib.instance.api.crateApiFfiBridgeUndo();

/// Redo the last undone operation
///
/// Executes the inverse of the last undone operation and pushes it back to the undo stack.
/// Returns true if an operation was redone, false if the redo stack is empty.
Future<bool> redo() => RustLib.instance.api.crateApiFfiBridgeRedo();

/// Check if undo is available
Future<bool> canUndo() => RustLib.instance.api.crateApiFfiBridgeCanUndo();

/// Check if redo is available
Future<bool> canRedo() => RustLib.instance.api.crateApiFfiBridgeCanRedo();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < BackendEngine >>>
abstract class ArcBackendEngine implements RustOpaqueInterface {}

/// flutter_rust_bridge:non_opaque
class MapChangeSink {
  final RustStreamSink<BatchMapChangeWithMetadata> sink;

  const MapChangeSink({required this.sink});

  @override
  int get hashCode => sink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MapChangeSink &&
          runtimeType == other.runtimeType &&
          sink == other.sink;
}
