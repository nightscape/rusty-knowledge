// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../third_party/holon_api.dart';
import '../third_party/holon_api/block.dart';
import '../third_party/holon_api/streaming.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

/// Create a Traversal for only top-level user blocks (level 1)
Future<Traversal> traversalTopLevel() =>
    RustLib.instance.api.crateApiRepositoryTraversalTopLevel();

/// Create a Traversal for all blocks including the synthetic root
Future<Traversal> traversalAll() =>
    RustLib.instance.api.crateApiRepositoryTraversalAll();

/// Create a Traversal for all blocks except the synthetic root
Future<Traversal> traversalAllButRoot() =>
    RustLib.instance.api.crateApiRepositoryTraversalAllButRoot();

/// Create a custom Traversal with specific depth range
Future<Traversal> traversalNew({
  required BigInt minLevel,
  required BigInt maxLevel,
}) => RustLib.instance.api.crateApiRepositoryTraversalNew(
  minLevel: minLevel,
  maxLevel: maxLevel,
);

/// Create a StreamPosition representing the beginning of the stream
Future<StreamPosition> streamPositionBeginning() =>
    RustLib.instance.api.crateApiRepositoryStreamPositionBeginning();

/// Create a StreamPosition from a version vector
Future<StreamPosition> streamPositionVersion({required List<int> version}) =>
    RustLib.instance.api.crateApiRepositoryStreamPositionVersion(
      version: version,
    );

/// Get the ID of a block
String blockGetId({required Block block}) =>
    RustLib.instance.api.crateApiRepositoryBlockGetId(block: block);

/// Get the parent ID of a block
String blockGetParentId({required Block block}) =>
    RustLib.instance.api.crateApiRepositoryBlockGetParentId(block: block);

/// Get the content of a block
String blockGetContent({required Block block}) =>
    RustLib.instance.api.crateApiRepositoryBlockGetContent(block: block);

/// Get the children IDs of a block
List<String> blockGetChildren({required Block block}) =>
    RustLib.instance.api.crateApiRepositoryBlockGetChildren(block: block);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NewBlock>>
abstract class NewBlock implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RustDocumentRepository>>
abstract class RustDocumentRepository implements RustOpaqueInterface {
  /// Start accepting incoming P2P connections.
  Future<void> acceptConnections();

  /// Connect to a remote peer for P2P synchronization.
  Future<void> connectToPeer({required String peerNodeId});

  /// Create a new block.
  Future<Block> createBlock({
    required String parentId,
    required String content,
    String? id,
  });

  /// Create multiple blocks in a single transaction.
  Future<List<Block>> createBlocks({required List<NewBlock> blocks});

  /// Create a new document repository.
  static Future<RustDocumentRepository> createNew({required String docId}) =>
      RustLib.instance.api.crateApiRepositoryRustDocumentRepositoryCreateNew(
        docId: docId,
      );

  /// Delete a block (tombstone).
  Future<void> deleteBlock({required String id});

  /// Delete a block using a block reference.
  ///
  /// This method accepts a block directly rather than requiring ID extraction.
  Future<void> deleteBlockByRef({required Block block});

  /// Delete multiple blocks in a single transaction.
  Future<void> deleteBlocks({required List<String> ids});

  /// Dispose of document and release resources.
  @override
  Future<void> dispose();

  /// Get all non-deleted blocks in tree order.
  Future<List<Block>> getAllBlocks({required Traversal traversal});

  /// Get a block by ID.
  Future<Block> getBlock({required String id});

  /// Get multiple blocks by ID.
  Future<List<Block>> getBlocks({required List<String> ids});

  /// Get the current version vector of the document.
  Future<Uint8List> getCurrentVersion();

  /// Get this node's P2P identifier.
  Future<String> getNodeId();

  /// List children IDs of a block in display order.
  Future<List<String>> listChildren({required String parentId});

  /// Move block to new parent and position.
  Future<void> moveBlock({
    required String id,
    required String newParent,
    String? after,
  });

  /// Move block to new parent and position using block references.
  ///
  /// All arguments are block references instead of IDs, making it easier to
  /// work with opaque types in FFI scenarios.
  ///
  /// # Arguments
  ///
  /// * `block` - Block to move
  /// * `new_parent` - New parent block (None = move to root)
  /// * `after` - Insert after this sibling (None = insert at start)
  Future<void> moveBlockByRef({
    required Block block,
    Block? newParent,
    Block? after,
  });

  /// Open an existing document repository.
  static Future<RustDocumentRepository> openExisting({required String docId}) =>
      RustLib.instance.api.crateApiRepositoryRustDocumentRepositoryOpenExisting(
        docId: docId,
      );

  /// Unsubscribe from change stream and stop the background task.
  Future<void> unsubscribe();

  /// Update block content.
  Future<void> updateBlock({required String id, required String content});

  /// Update block content using a block reference.
  ///
  /// This method is designed for FFI scenarios where the UI works with opaque
  /// block types and shouldn't need to extract IDs explicitly.
  Future<void> updateBlockByRef({
    required Block block,
    required String content,
  });

  /// Subscribe to document changes since a specific position.
  ///
  /// This method uses flutter_rust_bridge's StreamSink pattern to send changes
  /// to Flutter. The stream will continue until either:
  /// - The sink is dropped on the Dart side
  /// - The backend shuts down
  Stream<BlockChange> watchChangesSince({required StreamPosition position});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Traversal>>
abstract class Traversal implements RustOpaqueInterface {}
