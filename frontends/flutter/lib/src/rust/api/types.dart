// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `_ChangeOrigin`, `_RowChangePlaceholder`, `_StreamPosition`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpanContext>>
abstract class SpanContext implements RustOpaqueInterface {}

@freezed
sealed class ApiError with _$ApiError implements FrbException {
  const ApiError._();

  const factory ApiError.blockNotFound({required String id}) =
      ApiError_BlockNotFound;
  const factory ApiError.documentNotFound({required String docId}) =
      ApiError_DocumentNotFound;
  const factory ApiError.cyclicMove({
    required String id,
    required String targetParent,
  }) = ApiError_CyclicMove;
  const factory ApiError.invalidOperation({required String message}) =
      ApiError_InvalidOperation;
  const factory ApiError.networkError({required String message}) =
      ApiError_NetworkError;
  const factory ApiError.internalError({required String message}) =
      ApiError_InternalError;
}

/// Trace context for propagating OpenTelemetry trace information across FFI boundary.
///
/// Uses W3C TraceContext format (traceparent header format) for serialization.
/// flutter_rust_bridge:non_opaque
class TraceContext {
  /// Trace ID (16-byte hex string, 32 hex characters)
  final String traceId;

  /// Span ID (8-byte hex string, 16 hex characters)
  final String spanId;

  /// Trace flags (1 byte, typically 0x01 for sampled)
  final int traceFlags;

  /// Optional trace state (key-value pairs)
  final String? traceState;

  const TraceContext({
    required this.traceId,
    required this.spanId,
    required this.traceFlags,
    this.traceState,
  });

  /// Create a new TraceContext from OpenTelemetry span context
  static Future<TraceContext> fromSpanContext({
    required SpanContext spanContext,
  }) => RustLib.instance.api.crateApiTypesTraceContextFromSpanContext(
    spanContext: spanContext,
  );

  /// Convert to OpenTelemetry span context
  Future<SpanContext?> toSpanContext() =>
      RustLib.instance.api.crateApiTypesTraceContextToSpanContext(that: this);

  @override
  int get hashCode =>
      traceId.hashCode ^
      spanId.hashCode ^
      traceFlags.hashCode ^
      traceState.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TraceContext &&
          runtimeType == other.runtimeType &&
          traceId == other.traceId &&
          spanId == other.spanId &&
          traceFlags == other.traceFlags &&
          traceState == other.traceState;
}
