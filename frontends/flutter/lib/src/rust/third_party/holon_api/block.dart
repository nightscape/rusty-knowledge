// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../holon_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'block.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BlockWithDepth`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `depth`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `error`, `new_source`, `new_text`, `new`, `set_property`, `source`, `text`, `text`, `with_header_arg`, `with_name`, `with_results`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SourceBlock>>
abstract class SourceBlock implements RustOpaqueInterface {
  /// Get a header argument by key
  Future<Value?> getHeaderArg({required String key});

  /// Check if this is a PRQL source block
  Future<bool> isPrql();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>>
abstract class Str implements RustOpaqueInterface {}

/// A block in the hierarchical document structure.
///
/// Blocks use URI-based IDs to support integration with external systems:
/// - Local blocks: `local://<uuid-v4>` (e.g., `local://550e8400-e29b-41d4-a716-446655440000`)
/// - External systems: `todoist://task/12345`, `logseq://page/abc123`
///
/// # Example
///
/// ```rust
/// use holon_api::{Block, BlockContent};
///
/// // Text block
/// let block = Block {
///     id: "local://550e8400-e29b-41d4-a716-446655440000".to_string(),
///     parent_id: "parent_id".to_string(),
///     content: BlockContent::text("My first block"),
///     properties: Default::default(),
///     children: vec![],
///     metadata: Default::default(),
/// };
///
/// // PRQL source block
/// let query_block = Block {
///     id: "local://query-1".to_string(),
///     parent_id: "parent_id".to_string(),
///     content: BlockContent::source("prql", "from tasks | filter completed == false"),
///     properties: Default::default(),
///     children: vec![],
///     metadata: Default::default(),
/// };
/// ```
/// flutter_rust_bridge:non_opaque
class Block {
  /// URI-based unique identifier
  final String id;

  /// Parent block ID
  final String parentId;

  /// Typed content (text, source block, etc.)
  final BlockContent content;

  /// Key-value properties (Tier 2: works fully in Org + Loro)
  /// Supports arbitrary metadata like tags, priorities, dates
  final Map<String, Value> properties;

  /// IDs of child blocks in display order
  final List<String> children;

  /// Block metadata (timestamps, etc.)
  final BlockMetadata metadata;

  const Block({
    required this.id,
    required this.parentId,
    required this.content,
    required this.properties,
    required this.children,
    required this.metadata,
  });

  /// Get the plain text content of this block.
  /// For text blocks, returns the raw text.
  /// For source blocks, returns the source code.
  Future<void> contentText() =>
      RustLib.instance.api.holonApiBlockBlockContentText(that: this);

  /// Get a property value by key
  Future<Value?> getProperty({required String key}) =>
      RustLib.instance.api.holonApiBlockBlockGetProperty(that: this, key: key);

  /// Check if this block contains a PRQL source block
  Future<bool> isPrqlBlock() =>
      RustLib.instance.api.holonApiBlockBlockIsPrqlBlock(that: this);

  /// Check if this block contains a source block
  Future<bool> isSourceBlock() =>
      RustLib.instance.api.holonApiBlockBlockIsSourceBlock(that: this);

  @override
  int get hashCode =>
      id.hashCode ^
      parentId.hashCode ^
      content.hashCode ^
      properties.hashCode ^
      children.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Block &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          parentId == other.parentId &&
          content == other.content &&
          properties == other.properties &&
          children == other.children &&
          metadata == other.metadata;
}

@freezed
sealed class BlockContent with _$BlockContent {
  const BlockContent._();

  /// Plain text content (paragraphs, prose)
  const factory BlockContent.text({
    /// Raw text content
    required String raw,
  }) = BlockContent_Text;

  /// Source code block (language-agnostic)
  const factory BlockContent.source(SourceBlock field0) = BlockContent_Source;

  /// Get the source block if this is a Source variant
  Future<SourceBlock?> asSource() =>
      RustLib.instance.api.holonApiBlockBlockContentAsSource(that: this);

  /// Get the raw text if this is a Text variant
  Future<Str?> asText() =>
      RustLib.instance.api.holonApiBlockBlockContentAsText(that: this);

  static Future<BlockContent> default_() =>
      RustLib.instance.api.holonApiBlockBlockContentDefault();

  /// Get a plain text representation (for search, display, etc.)
  Future<void> toPlainText() =>
      RustLib.instance.api.holonApiBlockBlockContentToPlainText(that: this);
}

/// Metadata associated with a block.
///
/// Note: UI state like `collapsed` is NOT stored here - it's kept locally
/// in the frontend to avoid cross-user UI churn in collaborative sessions.
/// flutter_rust_bridge:non_opaque
class BlockMetadata {
  /// Unix timestamp (milliseconds) when block was created
  final PlatformInt64 createdAt;

  /// Unix timestamp (milliseconds) when block was last updated
  final PlatformInt64 updatedAt;

  const BlockMetadata({required this.createdAt, required this.updatedAt});

  static Future<BlockMetadata> default_() =>
      RustLib.instance.api.holonApiBlockBlockMetadataDefault();

  @override
  int get hashCode => createdAt.hashCode ^ updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockMetadata &&
          runtimeType == other.runtimeType &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Results from executing a source block.
///
/// flutter_rust_bridge:non_opaque
class BlockResult {
  /// The output content
  final ResultOutput output;

  /// Unix timestamp (milliseconds) when the block was executed
  final PlatformInt64 executedAt;

  const BlockResult({required this.output, required this.executedAt});

  /// Create a table result
  static Future<BlockResult> table({
    required List<String> headers,
    required List<List<Value>> rows,
  }) => RustLib.instance.api.holonApiBlockBlockResultTable(
    headers: headers,
    rows: rows,
  );

  @override
  int get hashCode => output.hashCode ^ executedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockResult &&
          runtimeType == other.runtimeType &&
          output == other.output &&
          executedAt == other.executedAt;
}

@freezed
sealed class ResultOutput with _$ResultOutput {
  const ResultOutput._();

  /// Plain text output
  const factory ResultOutput.text({required String content}) =
      ResultOutput_Text;

  /// Tabular output (from queries)
  const factory ResultOutput.table({
    required List<String> headers,
    required List<List<Value>> rows,
  }) = ResultOutput_Table;

  /// Error output
  const factory ResultOutput.error({required String message}) =
      ResultOutput_Error;
}

/// A source code block with optional metadata.
///
/// Supports three tiers of features:
/// - Tier 1 (all formats): language + source code
/// - Tier 2 (Org + Loro): name, header_args, results
/// - Tier 3 (Loro only): inherited from Block's CRDT features
///
/// In Org Mode: `#+BEGIN_SRC language :arg1 val1 ... #+END_SRC`
/// In Markdown: ` ```language ... ``` `
/// In Loro: Native storage with full fidelity
///
/// flutter_rust_bridge:non_opaque
class SourceBlock {
  /// Language identifier (e.g., "prql", "sql", "python", "rust")
  final String language;

  /// The source code itself
  final String source;

  /// Optional block name for references (#+NAME: in Org Mode)
  /// Tier 2: Supported in Org Mode and Loro, lost in Markdown
  final String? name;

  /// Header arguments / parameters
  /// Tier 2: Supported in Org Mode (`:var x=1 :results table`) and Loro
  /// Examples for PRQL: { "connection": "main", "results": "table" }
  final Map<String, Value> headerArgs;

  /// Cached execution results
  /// Tier 2: Supported in Org Mode (#+RESULTS:) and Loro
  final BlockResult? results;

  const SourceBlock({
    required this.language,
    required this.source,
    this.name,
    required this.headerArgs,
    this.results,
  });

  /// Get a header argument by key
  Future<Value?> getHeaderArg({required String key}) => RustLib.instance.api
      .holonApiBlockSourceBlockGetHeaderArg(that: this, key: key);

  /// Check if this is a PRQL source block
  Future<bool> isPrql() =>
      RustLib.instance.api.holonApiBlockSourceBlockIsPrql(that: this);

  @override
  int get hashCode =>
      language.hashCode ^
      source.hashCode ^
      name.hashCode ^
      headerArgs.hashCode ^
      results.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceBlock &&
          runtimeType == other.runtimeType &&
          language == other.language &&
          source == other.source &&
          name == other.name &&
          headerArgs == other.headerArgs &&
          results == other.results;
}
