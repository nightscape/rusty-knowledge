// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../holon_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `EntitySchema`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `indexed`, `new`, `new`, `new`, `nullable`, `primary_key`, `set`, `with_field`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicEntity>>
abstract class DynamicEntity implements RustOpaqueInterface {
  static Future<DynamicEntity> default_() =>
      RustLib.instance.api.holonApiEntityDynamicEntityDefault();

  Future<Value?> get_({required String name});

  Future<bool?> getBool({required String name});

  Future<double?> getF64({required String name});

  Future<PlatformInt64?> getI64({required String name});

  Future<Value?> getMut({required String name});

  Future<String?> getString({required String name});

  Future<bool> hasField({required String name});

  Future<Value?> remove({required String name});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntityFieldSchema>>
abstract class EntityFieldSchema implements RustOpaqueInterface {
  FieldType get fieldType;

  bool get indexed;

  String get name;

  bool get required;

  set fieldType(FieldType fieldType);

  set indexed(bool indexed);

  set name(String name);

  set required(bool required_);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FieldType>>
abstract class FieldType implements RustOpaqueInterface {
  /// Convert to SQLite type string
  Future<void> toSqliteType();
}

abstract class HasSchema {
  /// Convert this entity to a dynamic representation
  Future<DynamicEntity> toEntity();
}

/// A dynamic entity with runtime-determined fields.
///
/// This provides a type-erased representation of any entity,
/// useful for generic storage and serialization.
///
/// flutter_rust_bridge:non_opaque
class DynamicEntity {
  final String typeName;
  final Map<String, Value> fields;

  const DynamicEntity({required this.typeName, required this.fields});

  static Future<DynamicEntity> default_() =>
      RustLib.instance.api.holonApiEntityDynamicEntityDefault();

  Future<Value?> get_({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityGet(that: this, name: name);

  Future<bool?> getBool({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityGetBool(that: this, name: name);

  Future<double?> getF64({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityGetF64(that: this, name: name);

  Future<PlatformInt64?> getI64({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityGetI64(that: this, name: name);

  Future<Value?> getMut({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityGetMut(that: this, name: name);

  Future<String?> getString({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityGetString(that: this, name: name);

  Future<bool> hasField({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityHasField(that: this, name: name);

  Future<Value?> remove({required String name}) => RustLib.instance.api
      .holonApiEntityDynamicEntityRemove(that: this, name: name);

  @override
  int get hashCode => typeName.hashCode ^ fields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DynamicEntity &&
          runtimeType == other.runtimeType &&
          typeName == other.typeName &&
          fields == other.fields;
}

/// Schema for a single field in a table.
class FieldSchema {
  final String name;
  final String sqlType;
  final bool nullable;
  final bool primaryKey;
  final bool indexed;

  const FieldSchema({
    required this.name,
    required this.sqlType,
    required this.nullable,
    required this.primaryKey,
    required this.indexed,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      sqlType.hashCode ^
      nullable.hashCode ^
      primaryKey.hashCode ^
      indexed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FieldSchema &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          sqlType == other.sqlType &&
          nullable == other.nullable &&
          primaryKey == other.primaryKey &&
          indexed == other.indexed;
}

/// Schema for a database table, used for DDL generation.
class Schema {
  final String tableName;
  final List<FieldSchema> fields;

  const Schema({required this.tableName, required this.fields});

  /// Generate CREATE TABLE SQL statement
  Future<String> toCreateTableSql() =>
      RustLib.instance.api.holonApiEntitySchemaToCreateTableSql(that: this);

  /// Generate CREATE INDEX SQL statements for indexed fields
  Future<List<String>> toIndexSql() =>
      RustLib.instance.api.holonApiEntitySchemaToIndexSql(that: this);

  @override
  int get hashCode => tableName.hashCode ^ fields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Schema &&
          runtimeType == other.runtimeType &&
          tableName == other.tableName &&
          fields == other.fields;
}
