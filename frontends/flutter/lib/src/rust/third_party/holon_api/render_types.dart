// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../holon_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'render_types.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Operation`, `RenderableItem`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `new`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `from_params`, `new`, `with_entity_name`

/// flutter_rust_bridge:non_opaque
class Arg {
  final String? name;
  final RenderExpr value;

  const Arg({this.name, required this.value});

  @override
  int get hashCode => name.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Arg &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          value == other.value;
}

/// flutter_rust_bridge:non_opaque
enum BinaryOperator { eq, neq, gt, lt, gte, lte, add, sub, mul, div, and, or }

/// Complete metadata for an operation
///
/// Generated by #[operations_trait] macro.
/// flutter_rust_bridge:non_opaque
class OperationDescriptor {
  final String entityName;

  /// Short name for entity-typed params (e.g., "task" for task_id, "project" for project_id)
  final String entityShortName;
  final String idColumn;
  final String name;
  final String displayName;
  final String description;
  final List<OperationParam> requiredParams;

  /// Fields that this operation affects (for pie menu auto-attachment)
  final List<String> affectedFields;

  /// How to derive required params from alternative sources (e.g., tree_position â†’ parent_id)
  final List<ParamMapping> paramMappings;

  /// flutter_rust_bridge:opaque
  final ArcBoxPreconditionChecker? precondition;

  const OperationDescriptor({
    required this.entityName,
    required this.entityShortName,
    required this.idColumn,
    required this.name,
    required this.displayName,
    required this.description,
    required this.requiredParams,
    required this.affectedFields,
    required this.paramMappings,
    this.precondition,
  });

  @override
  int get hashCode =>
      entityName.hashCode ^
      entityShortName.hashCode ^
      idColumn.hashCode ^
      name.hashCode ^
      displayName.hashCode ^
      description.hashCode ^
      requiredParams.hashCode ^
      affectedFields.hashCode ^
      paramMappings.hashCode ^
      precondition.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OperationDescriptor &&
          runtimeType == other.runtimeType &&
          entityName == other.entityName &&
          entityShortName == other.entityShortName &&
          idColumn == other.idColumn &&
          name == other.name &&
          displayName == other.displayName &&
          description == other.description &&
          requiredParams == other.requiredParams &&
          affectedFields == other.affectedFields &&
          paramMappings == other.paramMappings &&
          precondition == other.precondition;
}

/// Parameter descriptor for operation metadata
///
/// Describes a required parameter for an operation.
/// flutter_rust_bridge:non_opaque
class OperationParam {
  final String name;
  final TypeHint typeHint;
  final String description;

  const OperationParam({
    required this.name,
    required this.typeHint,
    required this.description,
  });

  @override
  int get hashCode => name.hashCode ^ typeHint.hashCode ^ description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OperationParam &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          typeHint == other.typeHint &&
          description == other.description;
}

/// Connects lineage analysis results to operation metadata
///
/// Embedded in FunctionCall nodes in RenderSpec and sent to Flutter frontend.
/// flutter_rust_bridge:non_opaque
class OperationWiring {
  final String widgetType;
  final String modifiedParam;
  final OperationDescriptor descriptor;

  const OperationWiring({
    required this.widgetType,
    required this.modifiedParam,
    required this.descriptor,
  });

  @override
  int get hashCode =>
      widgetType.hashCode ^ modifiedParam.hashCode ^ descriptor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OperationWiring &&
          runtimeType == other.runtimeType &&
          widgetType == other.widgetType &&
          modifiedParam == other.modifiedParam &&
          descriptor == other.descriptor;
}

/// Describes how to derive required parameters from alternative sources.
///
/// Enables auto-discovery: widgets provide generic params (like `tree_position` or `selected_id`),
/// and operations declare how to map those to their specific `required_params`.
/// flutter_rust_bridge:non_opaque
class ParamMapping {
  /// Source param name from widget (e.g., "tree_position", "selected_id")
  final String from;

  /// Which required params this source provides (e.g., ["parent_id", "predecessor"])
  final List<String> provides;

  /// Default values for params not extractable from source
  final Map<String, Value> defaults;

  const ParamMapping({
    required this.from,
    required this.provides,
    required this.defaults,
  });

  static Future<ParamMapping> default_() =>
      RustLib.instance.api.holonApiRenderTypesParamMappingDefault();

  @override
  int get hashCode => from.hashCode ^ provides.hashCode ^ defaults.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ParamMapping &&
          runtimeType == other.runtimeType &&
          from == other.from &&
          provides == other.provides &&
          defaults == other.defaults;
}

@freezed
sealed class RenderExpr with _$RenderExpr {
  const RenderExpr._();

  const factory RenderExpr.functionCall({
    required String name,
    required List<Arg> args,
    required List<OperationWiring> operations,
  }) = RenderExpr_FunctionCall;
  const factory RenderExpr.columnRef({required String name}) =
      RenderExpr_ColumnRef;
  const factory RenderExpr.literal({required Value value}) = RenderExpr_Literal;
  const factory RenderExpr.binaryOp({
    required BinaryOperator op,
    required RenderExpr left,
    required RenderExpr right,
  }) = RenderExpr_BinaryOp;
  const factory RenderExpr.array({required List<RenderExpr> items}) =
      RenderExpr_Array;
  const factory RenderExpr.object({required Map<String, RenderExpr> fields}) =
      RenderExpr_Object;
}

/// flutter_rust_bridge:non_opaque
class RenderSpec {
  final RenderExpr root;
  final List<String> nestedQueries;

  /// Automatically inferred operation wirings from lineage analysis
  /// Probably obsolete here, as we have the operations directly in the FunctionCall nodes now
  final Map<String, OperationWiring> operations;

  /// Per-row templates for heterogeneous UNION queries.
  /// Each template has an index that corresponds to the `ui` column value in SQL results.
  /// Operations are wired based on each template's source entity.
  final List<RowTemplate> rowTemplates;

  const RenderSpec({
    required this.root,
    required this.nestedQueries,
    required this.operations,
    required this.rowTemplates,
  });

  @override
  int get hashCode =>
      root.hashCode ^
      nestedQueries.hashCode ^
      operations.hashCode ^
      rowTemplates.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RenderSpec &&
          runtimeType == other.runtimeType &&
          root == other.root &&
          nestedQueries == other.nestedQueries &&
          operations == other.operations &&
          rowTemplates == other.rowTemplates;
}

/// Per-row UI template for heterogeneous data rendering.
///
/// When a PRQL query uses `derive { ui = (render ...) }` after a `from <table>`,
/// the compiler extracts the render expression and assigns it an index.
/// The SQL output will have `<index> as ui` for that table's rows.
/// At render time, Flutter looks up `row['ui']` to find the right template.
/// flutter_rust_bridge:non_opaque
class RowTemplate {
  /// Index used in the `ui` column to identify this template
  final BigInt index;

  /// Source entity name (e.g., "todoist_tasks", "todoist_projects")
  /// Used for wiring operations to the correct entity
  final String entityName;

  /// Short name for entity-typed params (e.g., "task", "project")
  /// Used for generating drop target params like "task_id", "project_id"
  final String entityShortName;

  /// The render expression with operations pre-wired for this entity
  final RenderExpr expr;

  const RowTemplate({
    required this.index,
    required this.entityName,
    required this.entityShortName,
    required this.expr,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      entityName.hashCode ^
      entityShortName.hashCode ^
      expr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RowTemplate &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          entityName == other.entityName &&
          entityShortName == other.entityShortName &&
          expr == other.expr;
}

@freezed
sealed class TypeHint with _$TypeHint {
  const TypeHint._();

  /// Boolean value
  const factory TypeHint.bool() = TypeHint_Bool;

  /// String value
  const factory TypeHint.string() = TypeHint_String;

  /// Numeric value (integer)
  const factory TypeHint.number() = TypeHint_Number;

  /// Reference to an entity ID
  ///
  /// Example: `EntityId { entity_name: "project" }` means this parameter
  /// must be the ID of a "project" entity.
  const factory TypeHint.entityId({required String entityName}) =
      TypeHint_EntityId;

  /// Convert from legacy string format for backward compatibility
  static Future<TypeHint> fromString({required String s}) =>
      RustLib.instance.api.holonApiRenderTypesTypeHintFromString(s: s);

  /// Convert to legacy string format for backward compatibility
  Future<String> toStringLegacy() => RustLib.instance.api
      .holonApiRenderTypesTypeHintToStringLegacy(that: this);
}
