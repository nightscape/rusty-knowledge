// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../holon_api.dart';
import 'block.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'streaming.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Batch`, `Change`, `WithMetadata`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref_mut`, `deref`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `from_current_span`, `from_json`, `from_span_context`, `is_local`, `local_with_current_span`, `operation_id`, `remote_with_current_span`, `to_batch_trace_context`, `to_json`, `trace_id`

/// Batch of changes for efficient transmission
///
/// Groups multiple changes together to reduce overhead when multiple changes
/// occur simultaneously (e.g., from a single RelationChangeEvent).
/// flutter_rust_bridge:non_opaque
class BatchMapChange {
  final List<MapChange> items;

  const BatchMapChange({required this.items});

  @override
  int get hashCode => items.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatchMapChange &&
          runtimeType == other.runtimeType &&
          items == other.items;
}

/// Generic wrapper for adding metadata to any type
///
/// This allows you to add metadata to any type without modifying the original type.
/// Implements Deref/DerefMut for ergonomic access to the inner type.
/// flutter_rust_bridge:non_opaque
class BatchMapChangeWithMetadata {
  /// The inner value
  final BatchMapChange inner;

  /// The metadata associated with this value
  final BatchMetadata metadata;

  const BatchMapChangeWithMetadata({
    required this.inner,
    required this.metadata,
  });

  @override
  int get hashCode => inner.hashCode ^ metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatchMapChangeWithMetadata &&
          runtimeType == other.runtimeType &&
          inner == other.inner &&
          metadata == other.metadata;
}

/// Metadata associated with a batch of changes
///
/// Contains information about where the batch originated from, including
/// the relation/view name and trace context for observability.
/// flutter_rust_bridge:non_opaque
class BatchMetadata {
  /// The view/relation that generated this batch
  final String relationName;

  /// OpenTelemetry trace context for the batch (if available)
  final BatchTraceContext? traceContext;

  /// Sync token to update atomically with the data changes
  final SyncTokenUpdate? syncToken;

  const BatchMetadata({
    required this.relationName,
    this.traceContext,
    this.syncToken,
  });

  @override
  int get hashCode =>
      relationName.hashCode ^ traceContext.hashCode ^ syncToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatchMetadata &&
          runtimeType == other.runtimeType &&
          relationName == other.relationName &&
          traceContext == other.traceContext &&
          syncToken == other.syncToken;
}

/// Trace context for batch metadata
///
/// Simplified trace context for batch metadata (separate from TraceContext
/// to avoid circular dependencies).
/// flutter_rust_bridge:non_opaque
class BatchTraceContext {
  /// Trace ID (32 hex characters)
  final String traceId;

  /// Span ID (16 hex characters)
  final String spanId;

  /// Trace flags
  final int traceFlags;

  const BatchTraceContext({
    required this.traceId,
    required this.spanId,
    required this.traceFlags,
  });

  @override
  int get hashCode => traceId.hashCode ^ spanId.hashCode ^ traceFlags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatchTraceContext &&
          runtimeType == other.runtimeType &&
          traceId == other.traceId &&
          spanId == other.spanId &&
          traceFlags == other.traceFlags;
}

@freezed
sealed class BlockChange with _$BlockChange {
  const BlockChange._();

  /// Block was created
  const factory BlockChange.created({
    required Block data,
    required ChangeOrigin origin,
  }) = BlockChange_Created;

  /// Block content was updated (character-level)
  const factory BlockChange.updated({
    required String id,
    required Block data,
    required ChangeOrigin origin,
  }) = BlockChange_Updated;

  /// Block was deleted (tombstone set)
  const factory BlockChange.deleted({
    required String id,
    required ChangeOrigin origin,
  }) = BlockChange_Deleted;
}

@freezed
sealed class ChangeOrigin with _$ChangeOrigin {
  const ChangeOrigin._();

  /// Change initiated by this client
  const factory ChangeOrigin.local({
    /// Span ID (16 hex chars) linking this change to the originating operation
    String? operationId,

    /// Trace ID (32 hex chars) for distributed tracing
    String? traceId,
  }) = ChangeOrigin_Local;

  /// Change received from P2P sync or external system
  const factory ChangeOrigin.remote({
    /// Span ID (16 hex chars) linking this change to the originating operation
    String? operationId,

    /// Trace ID (32 hex chars) for distributed tracing
    String? traceId,
  }) = ChangeOrigin_Remote;

  /// Create from BatchTraceContext
  static Future<ChangeOrigin> localFromBatchTraceContext({
    required BatchTraceContext ctx,
  }) => RustLib.instance.api
      .rustyKnowledgeApiStreamingChangeOriginLocalFromBatchTraceContext(
        ctx: ctx,
      );

  /// Create Local origin with explicit trace context
  static Future<ChangeOrigin> localWithTrace({
    String? traceId,
    String? operationId,
  }) =>
      RustLib.instance.api.rustyKnowledgeApiStreamingChangeOriginLocalWithTrace(
        traceId: traceId,
        operationId: operationId,
      );

  /// Create Remote from BatchTraceContext
  static Future<ChangeOrigin> remoteFromBatchTraceContext({
    required BatchTraceContext ctx,
  }) => RustLib.instance.api
      .rustyKnowledgeApiStreamingChangeOriginRemoteFromBatchTraceContext(
        ctx: ctx,
      );

  /// Create Remote origin with explicit trace context
  static Future<ChangeOrigin> remoteWithTrace({
    String? traceId,
    String? operationId,
  }) => RustLib.instance.api
      .rustyKnowledgeApiStreamingChangeOriginRemoteWithTrace(
        traceId: traceId,
        operationId: operationId,
      );
}

@freezed
sealed class MapChange with _$MapChange {
  const MapChange._();

  /// Block was created
  const factory MapChange.created({
    required Map<String, Value> data,
    required ChangeOrigin origin,
  }) = MapChange_Created;

  /// Block content was updated (character-level)
  const factory MapChange.updated({
    required String id,
    required Map<String, Value> data,
    required ChangeOrigin origin,
  }) = MapChange_Updated;

  /// Block was deleted (tombstone set)
  const factory MapChange.deleted({
    required String id,
    required ChangeOrigin origin,
  }) = MapChange_Deleted;
}

@freezed
sealed class StreamPosition with _$StreamPosition {
  const StreamPosition._();

  /// Start from the beginning: first stream all current blocks as Created events,
  /// then stream subsequent changes
  const factory StreamPosition.beginning() = StreamPosition_Beginning;

  /// Start from a specific version: stream only changes that occurred after this version
  const factory StreamPosition.version(Uint8List field0) =
      StreamPosition_Version;
}

/// Sync token update to be persisted atomically with data changes
///
/// Used to ensure sync token and data are written in the same transaction,
/// preventing "database is locked" errors and ensuring consistency.
/// flutter_rust_bridge:non_opaque
class SyncTokenUpdate {
  /// Provider name (e.g., "todoist")
  final String providerName;

  /// New stream position to save
  final StreamPosition position;

  const SyncTokenUpdate({required this.providerName, required this.position});

  @override
  int get hashCode => providerName.hashCode ^ position.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncTokenUpdate &&
          runtimeType == other.runtimeType &&
          providerName == other.providerName &&
          position == other.position;
}
