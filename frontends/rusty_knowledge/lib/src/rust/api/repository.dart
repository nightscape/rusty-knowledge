// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiError>>
abstract class ApiError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Block>>
abstract class Block implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockChange>>
abstract class BlockChange implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NewBlock>>
abstract class NewBlock implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RustDocumentRepository>>
abstract class RustDocumentRepository implements RustOpaqueInterface {
  /// Start accepting incoming P2P connections.
  Future<void> acceptConnections();

  /// Connect to a remote peer for P2P synchronization.
  Future<void> connectToPeer({required String peerNodeId});

  /// Create a new block.
  Future<Block> createBlock({
    required String parentId,
    required String content,
    String? id,
  });

  /// Create multiple blocks in a single transaction.
  Future<List<Block>> createBlocks({required List<NewBlock> blocks});

  /// Create a new document repository.
  static Future<RustDocumentRepository> createNew({required String docId}) =>
      RustLib.instance.api.crateApiRepositoryRustDocumentRepositoryCreateNew(
        docId: docId,
      );

  /// Delete a block (tombstone).
  Future<void> deleteBlock({required String id});

  /// Delete multiple blocks in a single transaction.
  Future<void> deleteBlocks({required List<String> ids});

  /// Dispose of document and release resources.
  @override
  Future<void> dispose();

  /// Get all non-deleted blocks in tree order.
  Future<List<Block>> getAllBlocks({required Traversal traversal});

  /// Get a block by ID.
  Future<Block> getBlock({required String id});

  /// Get multiple blocks by ID.
  Future<List<Block>> getBlocks({required List<String> ids});

  /// Get the current version vector of the document.
  Future<Uint8List> getCurrentVersion();

  /// Get this node's P2P identifier.
  Future<String> getNodeId();

  /// List children IDs of a block in display order.
  Future<List<String>> listChildren({required String parentId});

  /// Move block to new parent and position.
  Future<void> moveBlock({
    required String id,
    required String newParent,
    String? after,
  });

  /// Open an existing document repository.
  static Future<RustDocumentRepository> openExisting({required String docId}) =>
      RustLib.instance.api.crateApiRepositoryRustDocumentRepositoryOpenExisting(
        docId: docId,
      );

  /// Unsubscribe from change stream and stop the background task.
  Future<void> unsubscribe();

  /// Update block content.
  Future<void> updateBlock({required String id, required String content});

  /// Subscribe to document changes since a specific position.
  ///
  /// This method uses flutter_rust_bridge's StreamSink pattern to send changes
  /// to Flutter. The stream will continue until either:
  /// - The sink is dropped on the Dart side
  /// - The backend shuts down
  Stream<BlockChange> watchChangesSince({required StreamPosition position});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StreamPosition>>
abstract class StreamPosition implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Traversal>>
abstract class Traversal implements RustOpaqueInterface {}
