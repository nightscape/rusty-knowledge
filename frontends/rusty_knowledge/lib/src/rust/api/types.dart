// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

@freezed
sealed class MirrorApiError with _$MirrorApiError implements FrbException {
  const MirrorApiError._();

  const factory MirrorApiError.blockNotFound({required String id}) =
      MirrorApiError_BlockNotFound;
  const factory MirrorApiError.documentNotFound({required String docId}) =
      MirrorApiError_DocumentNotFound;
  const factory MirrorApiError.cyclicMove({
    required String id,
    required String targetParent,
  }) = MirrorApiError_CyclicMove;
  const factory MirrorApiError.invalidOperation({required String message}) =
      MirrorApiError_InvalidOperation;
  const factory MirrorApiError.networkError({required String message}) =
      MirrorApiError_NetworkError;
  const factory MirrorApiError.internalError({required String message}) =
      MirrorApiError_InternalError;
}

/// Mirror type for rusty_knowledge::api::Block
///
/// Fully serializable variant that FRB can expose to Dart with all fields accessible.
class MirrorBlock {
  final String id;
  final String parentId;
  final String content;
  final List<String> children;
  final MirrorBlockMetadata metadata;

  const MirrorBlock({
    required this.id,
    required this.parentId,
    required this.content,
    required this.children,
    required this.metadata,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      parentId.hashCode ^
      content.hashCode ^
      children.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MirrorBlock &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          parentId == other.parentId &&
          content == other.content &&
          children == other.children &&
          metadata == other.metadata;
}

@freezed
sealed class MirrorBlockChange with _$MirrorBlockChange {
  const MirrorBlockChange._();

  const factory MirrorBlockChange.created({
    required MirrorBlock block,
    required MirrorChangeOrigin origin,
  }) = MirrorBlockChange_Created;
  const factory MirrorBlockChange.updated({
    required String id,
    required String content,
    required MirrorChangeOrigin origin,
  }) = MirrorBlockChange_Updated;
  const factory MirrorBlockChange.deleted({
    required String id,
    required MirrorChangeOrigin origin,
  }) = MirrorBlockChange_Deleted;
  const factory MirrorBlockChange.moved({
    required String id,
    String? newParent,
    String? after,
    required MirrorChangeOrigin origin,
  }) = MirrorBlockChange_Moved;
}

/// Mirror type for rusty_knowledge::api::BlockMetadata
class MirrorBlockMetadata {
  final PlatformInt64 createdAt;
  final PlatformInt64 updatedAt;

  const MirrorBlockMetadata({required this.createdAt, required this.updatedAt});

  @override
  int get hashCode => createdAt.hashCode ^ updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MirrorBlockMetadata &&
          runtimeType == other.runtimeType &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Mirror type for rusty_knowledge::api::ChangeOrigin
enum MirrorChangeOrigin { local, remote }

/// Mirror type for rusty_knowledge::api::NewBlock
class MirrorNewBlock {
  final String? parentId;
  final String content;
  final String? after;
  final String? id;

  const MirrorNewBlock({
    this.parentId,
    required this.content,
    this.after,
    this.id,
  });

  @override
  int get hashCode =>
      parentId.hashCode ^ content.hashCode ^ after.hashCode ^ id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MirrorNewBlock &&
          runtimeType == other.runtimeType &&
          parentId == other.parentId &&
          content == other.content &&
          after == other.after &&
          id == other.id;
}

@freezed
sealed class MirrorStreamPosition with _$MirrorStreamPosition {
  const MirrorStreamPosition._();

  const factory MirrorStreamPosition.beginning() =
      MirrorStreamPosition_Beginning;
  const factory MirrorStreamPosition.version(Uint8List field0) =
      MirrorStreamPosition_Version;
}
